<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />
<style type="text/css" title="ibis-book">
    @charset "utf-8";#sbo-rt-content html,#sbo-rt-content div,#sbo-rt-content div,#sbo-rt-content span,#sbo-rt-content applet,#sbo-rt-content object,#sbo-rt-content iframe,#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5,#sbo-rt-content h6,#sbo-rt-content p,#sbo-rt-content blockquote,#sbo-rt-content pre,#sbo-rt-content a,#sbo-rt-content abbr,#sbo-rt-content acronym,#sbo-rt-content address,#sbo-rt-content big,#sbo-rt-content cite,#sbo-rt-content code,#sbo-rt-content del,#sbo-rt-content dfn,#sbo-rt-content em,#sbo-rt-content img,#sbo-rt-content ins,#sbo-rt-content kbd,#sbo-rt-content q,#sbo-rt-content s,#sbo-rt-content samp,#sbo-rt-content small,#sbo-rt-content strike,#sbo-rt-content strong,#sbo-rt-content sub,#sbo-rt-content sup,#sbo-rt-content tt,#sbo-rt-content var,#sbo-rt-content b,#sbo-rt-content u,#sbo-rt-content i,#sbo-rt-content center,#sbo-rt-content dl,#sbo-rt-content dt,#sbo-rt-content dd,#sbo-rt-content ol,#sbo-rt-content ul,#sbo-rt-content li,#sbo-rt-content fieldset,#sbo-rt-content form,#sbo-rt-content label,#sbo-rt-content legend,#sbo-rt-content table,#sbo-rt-content caption,#sbo-rt-content tdiv,#sbo-rt-content tfoot,#sbo-rt-content thead,#sbo-rt-content tr,#sbo-rt-content th,#sbo-rt-content td,#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content canvas,#sbo-rt-content details,#sbo-rt-content embed,#sbo-rt-content figure,#sbo-rt-content figcaption,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content output,#sbo-rt-content ruby,#sbo-rt-content section,#sbo-rt-content summary,#sbo-rt-content time,#sbo-rt-content mark,#sbo-rt-content audio,#sbo-rt-content video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content details,#sbo-rt-content figcaption,#sbo-rt-content figure,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content section{display:block}#sbo-rt-content div{line-height:1}#sbo-rt-content ol,#sbo-rt-content ul{list-style:none}#sbo-rt-content blockquote,#sbo-rt-content q{quotes:none}#sbo-rt-content blockquote:before,#sbo-rt-content blockquote:after,#sbo-rt-content q:before,#sbo-rt-content q:after{content:none}#sbo-rt-content table{border-collapse:collapse;border-spacing:0}@page{margin:5px !important}#sbo-rt-content p{margin:10px 0 0;line-height:125%;text-align:left}#sbo-rt-content p.byline{text-align:left;margin:-33px auto 35px;font-style:italic;font-weight:bold}#sbo-rt-content div.preface p+p.byline{margin:1em 0 0 !important}#sbo-rt-content div.preface p.byline+p.byline{margin:0 !important}#sbo-rt-content div.sect1&gt;p.byline{margin:-.25em 0 1em}#sbo-rt-content div.sect1&gt;p.byline+p.byline{margin-top:-1em}#sbo-rt-content em{font-style:italic;font-family:inherit}#sbo-rt-content em strong,#sbo-rt-content strong em{font-weight:bold;font-style:italic;font-family:inherit}#sbo-rt-content strong,#sbo-rt-content span.bold{font-weight:bold}#sbo-rt-content em.replaceable{font-style:italic}#sbo-rt-content strong.userinput{font-weight:bold;font-style:normal}#sbo-rt-content span.bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content a.ulink,#sbo-rt-content a.xref,#sbo-rt-content a.email,#sbo-rt-content a.link,#sbo-rt-content a{text-decoration:none;color:#8e0012}#sbo-rt-content span.lineannotation{font-style:italic;color:#a62a2a;font-family:serif}#sbo-rt-content span.underline{text-decoration:underline}#sbo-rt-content span.strikethrough{text-decoration:line-through}#sbo-rt-content span.smallcaps{font-variant:small-caps}#sbo-rt-content span.cursor{background:#000;color:#fff}#sbo-rt-content span.smaller{font-size:75%}#sbo-rt-content .boxedtext,#sbo-rt-content .keycap{border-style:solid;border-width:1px;border-color:#000;padding:1px}#sbo-rt-content span.gray50{color:#7F7F7F;}#sbo-rt-content h1,#sbo-rt-content div.toc-title,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5{-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;font-weight:bold;text-align:left;page-break-after:avoid !important;font-family:sans-serif,"DejaVuSans"}#sbo-rt-content div.toc-title{font-size:1.5em;margin-top:20px !important;margin-bottom:30px !important}#sbo-rt-content section[data-type="sect1"] h1{font-size:1.3em;color:#8e0012;margin:40px 0 8px 0}#sbo-rt-content section[data-type="sect2"] h2{font-size:1.1em;margin:30px 0 8px 0 !important}#sbo-rt-content section[data-type="sect3"] h3{font-size:1em;color:#555;margin:20px 0 8px 0 !important}#sbo-rt-content section[data-type="sect4"] h4{font-size:1em;font-weight:normal;font-style:italic;margin:15px 0 6px 0 !important}#sbo-rt-content section[data-type="chapter"]&gt;div&gt;h1,#sbo-rt-content section[data-type="preface"]&gt;div&gt;h1,#sbo-rt-content section[data-type="appendix"]&gt;div&gt;h1,#sbo-rt-content section[data-type="glossary"]&gt;div&gt;h1,#sbo-rt-content section[data-type="bibliography"]&gt;div&gt;h1,#sbo-rt-content section[data-type="index"]&gt;div&gt;h1{font-size:2em;line-height:1;margin-bottom:50px;color:#000;padding-bottom:10px;border-bottom:1px solid #000}#sbo-rt-content span.label,#sbo-rt-content span.keep-together{font-size:inherit;font-weight:inherit}#sbo-rt-content div[data-type="part"] h1{font-size:2em;text-align:center;margin-top:0 !important;margin-bottom:50px;padding:50px 0 10px 0;border-bottom:1px solid #000}#sbo-rt-content img.width-ninety{width:90%}#sbo-rt-content img{max-width:95%;margin:0 auto;padding:0}#sbo-rt-content div.figure{background-color:transparent;text-align:center !important;margin:15px auto !important;page-break-inside:avoid}#sbo-rt-content figure{margin:15px auto !important;page-break-inside:avoid}#sbo-rt-content div.figure h6,#sbo-rt-content figure h6,#sbo-rt-content figure figcaption{font-size:.9rem !important;text-align:center;font-weight:normal !important;font-style:italic;font-family:serif !important;text-transform:none !important;letter-spacing:normal !important;color:#000;padding-top:.25em !important;margin-top:0 !important;page-break-before:avoid}#sbo-rt-content div.informalfigure{text-align:center !important;padding:5px 0 !important}#sbo-rt-content div.sidebar{margin:15px 0 10px 0 !important;border:1px solid #DCDCDC;background-color:#F7F7F7;padding:15px !important;page-break-inside:avoid}#sbo-rt-content aside[data-type="sidebar"]{margin:15px 0 10px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar-title,#sbo-rt-content aside[data-type="sidebar"] h5{font-weight:bold;font-size:1em;font-family:sans-serif;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar ol,#sbo-rt-content div.sidebar ul,#sbo-rt-content aside[data-type="sidebar"] ol,#sbo-rt-content aside[data-type="sidebar"] ul{margin-left:1.25em !important}#sbo-rt-content div.sidebar div.figure p.title,#sbo-rt-content aside[data-type="sidebar"] figcaption,#sbo-rt-content div.sidebar div.informalfigure div.caption{font-size:90%;text-align:center;font-weight:normal;font-style:italic;font-family:serif !important;color:#000;padding:5px !important;page-break-before:avoid;page-break-after:avoid}#sbo-rt-content div.sidebar div.tip,#sbo-rt-content div.sidebar div[data-type="tip"],#sbo-rt-content div.sidebar div.note,#sbo-rt-content div.sidebar div[data-type="note"],#sbo-rt-content div.sidebar div.warning,#sbo-rt-content div.sidebar div[data-type="warning"],#sbo-rt-content div.sidebar div[data-type="caution"],#sbo-rt-content div.sidebar div[data-type="important"]{margin:20px auto 20px auto !important;font-size:90%;width:85%}#sbo-rt-content aside[data-type="sidebar"] p.byline{font-size:90%;font-weight:bold;font-style:italic;text-align:center;text-indent:0;margin:5px auto 6px;page-break-after:avoid}#sbo-rt-content pre{white-space:pre-wrap;font-family:"Ubuntu Mono",monospace;margin:25px 0 25px 20px;font-size:85%;display:block;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content div.note pre.programlisting,#sbo-rt-content div.tip pre.programlisting,#sbo-rt-content div.warning pre.programlisting,#sbo-rt-content div.caution pre.programlisting,#sbo-rt-content div.important pre.programlisting{margin-bottom:0}#sbo-rt-content code{font-family:"Ubuntu Mono",monospace;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content code strong em,#sbo-rt-content code em strong,#sbo-rt-content pre em strong,#sbo-rt-content pre strong em,#sbo-rt-content strong code em code,#sbo-rt-content em code strong code,#sbo-rt-content span.bolditalic code{font-weight:bold;font-style:italic;font-family:"Ubuntu Mono BoldItal",monospace}#sbo-rt-content code em,#sbo-rt-content em code,#sbo-rt-content pre em,#sbo-rt-content em.replaceable{font-family:"Ubuntu Mono Ital",monospace;font-style:italic}#sbo-rt-content code strong,#sbo-rt-content strong code,#sbo-rt-content pre strong,#sbo-rt-content strong.userinput{font-family:"Ubuntu Mono Bold",monospace;font-weight:bold}#sbo-rt-content div[data-type="example"]{margin:10px 0 15px 0 !important}#sbo-rt-content div[data-type="example"] h1,#sbo-rt-content div[data-type="example"] h2,#sbo-rt-content div[data-type="example"] h3,#sbo-rt-content div[data-type="example"] h4,#sbo-rt-content div[data-type="example"] h5,#sbo-rt-content div[data-type="example"] h6{font-style:italic;font-weight:normal;text-align:left !important;text-transform:none !important;font-family:serif !important;margin:10px 0 5px 0 !important;border-bottom:1px solid #000}#sbo-rt-content li pre.example{padding:10px 0 !important}#sbo-rt-content div[data-type="example"] pre[data-type="programlisting"],#sbo-rt-content div[data-type="example"] pre[data-type="screen"]{margin:0}#sbo-rt-content section[data-type="titlepage"]&gt;div&gt;h1{font-size:2em;margin:50px 0 10px 0 !important;line-height:1;text-align:center}#sbo-rt-content section[data-type="titlepage"] h2,#sbo-rt-content section[data-type="titlepage"] p.subtitle,#sbo-rt-content section[data-type="titlepage"] p[data-type="subtitle"]{font-size:1.3em;font-weight:normal;text-align:center;margin-top:.5em;color:#555}#sbo-rt-content section[data-type="titlepage"]&gt;div&gt;h2[data-type="author"],#sbo-rt-content section[data-type="titlepage"] p.author{font-size:1.3em;font-family:serif !important;font-weight:bold;margin:50px 0 !important;text-align:center}#sbo-rt-content section[data-type="titlepage"] p.edition{text-align:center;text-transform:uppercase;margin-top:2em}#sbo-rt-content section[data-type="titlepage"]{text-align:center}#sbo-rt-content section[data-type="titlepage"]:after{content:url(css_assets/titlepage_footer_ebook.png);margin:0 auto;max-width:80%}#sbo-rt-content div.book div.titlepage div.publishername{margin-top:60%;margin-bottom:20px;text-align:center;font-size:1.25em}#sbo-rt-content div.book div.titlepage div.locations p{margin:0;text-align:center}#sbo-rt-content div.book div.titlepage div.locations p.cities{font-size:80%;text-align:center;margin-top:5px}#sbo-rt-content section.preface[title="Dedication"]&gt;div.titlepage h2.title{text-align:center;text-transform:uppercase;font-size:1.5em;margin-top:50px;margin-bottom:50px}#sbo-rt-content ul.stafflist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.stafflist li{list-style-type:none;padding:5px 0}#sbo-rt-content ul.printings li{list-style-type:none}#sbo-rt-content section.preface[title="Dedication"] p{font-style:italic;text-align:center}#sbo-rt-content div.colophon h1.title{font-size:1.3em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon h2.subtitle{margin:0 !important;color:#000;font-family:serif !important;font-size:1em;font-weight:normal}#sbo-rt-content div.colophon div.author h3.author{font-size:1.1em;font-family:serif !important;margin:10px 0 0 !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h4,#sbo-rt-content div.colophon div.editor h3.editor{color:#000;font-size:.8em;margin:15px 0 0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h3.editor{font-size:.8em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.publisher{margin-top:10px}#sbo-rt-content div.colophon div.publisher p,#sbo-rt-content div.colophon div.publisher span.publishername{margin:0;font-size:.8em}#sbo-rt-content div.legalnotice p,#sbo-rt-content div.timestamp p{font-size:.8em}#sbo-rt-content div.timestamp p{margin-top:10px}#sbo-rt-content div.colophon[title="About the Author"] h1.title,#sbo-rt-content div.colophon[title="Colophon"] h1.title{font-size:1.5em;margin:0 !important;font-family:sans-serif !important}#sbo-rt-content section.chapter div.titlepage div.author{margin:10px 0 10px 0}#sbo-rt-content section.chapter div.titlepage div.author div.affiliation{font-style:italic}#sbo-rt-content div.attribution{margin:5px 0 0 50px !important}#sbo-rt-content h3.author span.orgname{display:none}#sbo-rt-content div.epigraph{margin:10px 0 10px 20px !important;page-break-inside:avoid;font-size:90%}#sbo-rt-content div.epigraph p{font-style:italic}#sbo-rt-content blockquote,#sbo-rt-content div.blockquote{margin:10px !important;page-break-inside:avoid;font-size:95%}#sbo-rt-content blockquote p,#sbo-rt-content div.blockquote p{font-style:italic;margin:.75em 0 0 !important}#sbo-rt-content blockquote div.attribution,#sbo-rt-content blockquote p[data-type="attribution"]{margin:5px 0 10px 30px !important;text-align:right;width:80%}#sbo-rt-content blockquote div.attribution p,#sbo-rt-content blockquote p[data-type="attribution"]{font-style:normal;margin-top:5px}#sbo-rt-content blockquote div.attribution p:before,#sbo-rt-content blockquote p[data-type="attribution"]:before{font-style:normal;content:"—";-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none}#sbo-rt-content p.right{text-align:right;margin:0}#sbo-rt-content div[data-type="footnotes"]{border-top:1px solid black;margin-top:2em}#sbo-rt-content sub,#sbo-rt-content sup{font-size:75%;line-height:0;position:relative}#sbo-rt-content sup{top:-.5em}#sbo-rt-content sub{bottom:-.25em}#sbo-rt-content p[data-type="footnote"]{font-size:90% !important;line-height:1.2em !important;margin-left:2.5em !important;text-indent:-2.3em !important}#sbo-rt-content p[data-type="footnote"] sup{display:inline-block !important;position:static !important;width:2em !important;text-align:right !important;font-size:100% !important;padding-right:.5em !important}#sbo-rt-content p[data-type="footnote"] a[href$="-marker"]{font-family:sans-serif !important;font-size:90% !important;color:#8e0012 !important}#sbo-rt-content p[data-type="footnote"] a[data-type="xref"]{margin:0 !important;padding:0 !important;text-indent:0 !important}#sbo-rt-content a[data-type="noteref"]{font-family:sans-serif !important;color:#8e0012;margin-left:0;padding-left:0}#sbo-rt-content div.refentry p.refname{font-size:1em;font-family:sans-serif,"DejaVuSans";font-weight:bold;margin-bottom:5px;overflow:auto;width:100%}#sbo-rt-content div.refentry{width:100%;display:block;margin-top:2em}#sbo-rt-content div.refsynopsisdiv{display:block;clear:both}#sbo-rt-content div.refentry header{page-break-inside:avoid !important;display:block;break-inside:avoid !important;padding-top:0;border-bottom:1px solid #000}#sbo-rt-content div.refsect1 h6{font-size:.9em;font-family:sans-serif,"DejaVuSans";font-weight:bold}#sbo-rt-content div.refsect1{margin-top:3em}#sbo-rt-content dl{margin-bottom:1.5em !important}#sbo-rt-content dt{padding-top:10px !important;padding-bottom:0 !important;line-height:1.25rem;font-style:italic}#sbo-rt-content dd{margin:10px 0 .25em 1.5em !important;line-height:1.65em !important}#sbo-rt-content dd p{padding:0 !important;margin:0 0 10px !important}#sbo-rt-content dd ol,#sbo-rt-content dd ul{padding-left:1em}#sbo-rt-content dd li{margin-top:0;margin-bottom:0}#sbo-rt-content dd,#sbo-rt-content li{text-align:left}#sbo-rt-content ul,#sbo-rt-content ul&gt;li,#sbo-rt-content ol ul,#sbo-rt-content ol ul&gt;li,#sbo-rt-content ul ol ul,#sbo-rt-content ul ol ul&gt;li{list-style-type:disc}#sbo-rt-content ul ul,#sbo-rt-content ul ul&gt;li{list-style-type:square}#sbo-rt-content ul ul ul,#sbo-rt-content ul ul ul&gt;li{list-style-type:circle}#sbo-rt-content ol,#sbo-rt-content ol&gt;li,#sbo-rt-content ol ul ol,#sbo-rt-content ol ul ol&gt;li,#sbo-rt-content ul ol,#sbo-rt-content ul ol&gt;li{list-style-type:decimal}#sbo-rt-content ol ol,#sbo-rt-content ol ol&gt;li{list-style-type:lower-alpha}#sbo-rt-content ol ol ol,#sbo-rt-content ol ol ol&gt;li{list-style-type:lower-roman}#sbo-rt-content ol,#sbo-rt-content ul{list-style-position:outside;margin:15px 0 15px 1.25em;padding-left:2.25em}#sbo-rt-content ol li,#sbo-rt-content ul li{margin:.5em 0 .65em;line-height:125%}#sbo-rt-content div.orderedlistalpha{list-style-type:upper-alpha}#sbo-rt-content table.simplelist,#sbo-rt-content ul.simplelist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.simplelist li{list-style-type:none;padding:5px 0}#sbo-rt-content table.simplelist td{border:none}#sbo-rt-content table.simplelist tr{border-bottom:none}#sbo-rt-content table.simplelist tr:nth-of-type(even){background-color:transparent}#sbo-rt-content dl.calloutlist p:first-child{margin-top:-25px !important}#sbo-rt-content dl.calloutlist dd{padding-left:0;margin-top:-25px}#sbo-rt-content dl.calloutlist img,#sbo-rt-content a.co img{padding:0}#sbo-rt-content div.toc ol{margin-top:8px !important;margin-bottom:8px !important;margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.toc ol ol{margin-left:30px !important;padding-left:0 !important}#sbo-rt-content div.toc ol li{list-style-type:none}#sbo-rt-content div.toc a{color:#8e0012}#sbo-rt-content div.toc ol a{font-size:1em;font-weight:bold}#sbo-rt-content div.toc ol&gt;li&gt;ol a{font-weight:bold;font-size:1em}#sbo-rt-content div.toc ol&gt;li&gt;ol&gt;li&gt;ol a{text-decoration:none;font-weight:normal;font-size:1em}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"],#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{margin:30px !important;font-size:90%;padding:10px 8px 20px 8px !important;page-break-inside:avoid}#sbo-rt-content div.tip ol,#sbo-rt-content div.tip ul,#sbo-rt-content div[data-type="tip"] ol,#sbo-rt-content div[data-type="tip"] ul,#sbo-rt-content div.note ol,#sbo-rt-content div.note ul,#sbo-rt-content div[data-type="note"] ol,#sbo-rt-content div[data-type="note"] ul,#sbo-rt-content div.warning ol,#sbo-rt-content div.warning ul,#sbo-rt-content div[data-type="warning"] ol,#sbo-rt-content div[data-type="warning"] ul,#sbo-rt-content div[data-type="caution"] ol,#sbo-rt-content div[data-type="caution"] ul,#sbo-rt-content div[data-type="important"] ol,#sbo-rt-content div[data-type="important"] ul{margin-left:1.5em !important}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"]{border:1px solid #BEBEBE;background-color:transparent}#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{border:1px solid #BC8F8F}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="note"] h1,#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1,#sbo-rt-content div[data-type="important"] h6{font-weight:bold;font-size:110%;font-family:sans-serif !important;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px !important}#sbo-rt-content div[data-type="tip"] figure h6,#sbo-rt-content div[data-type="note"] figure h6,#sbo-rt-content div[data-type="warning"] figure h6,#sbo-rt-content div[data-type="caution"] figure h6,#sbo-rt-content div[data-type="important"] figure h6{font-family:serif !important}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div[data-type="note"] h1{color:#737373}#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="important"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1{color:#C67171}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note,#sbo-rt-content div.safarienabled{background-color:transparent;margin:8px 0 0 !important;border:0 solid #BEBEBE;font-size:100%;padding:0 !important;page-break-inside:avoid}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note h3,#sbo-rt-content div.safarienabled h6{display:none}#sbo-rt-content div.table,#sbo-rt-content table{margin:15px 0 30px 0 !important;max-width:95%;border:none !important;background:none;display:table !important}#sbo-rt-content div.table,#sbo-rt-content div.informaltable,#sbo-rt-content table{page-break-inside:avoid}#sbo-rt-content table li{margin:10px 0 0 .25em !important}#sbo-rt-content tr,#sbo-rt-content tr td{border-bottom:1px solid #c3c3c3}#sbo-rt-content thead td,#sbo-rt-content thead th{border-bottom:#9d9d9d 1px solid !important;border-top:#9d9d9d 1px solid !important}#sbo-rt-content tr:nth-of-type(even){background-color:#f1f6fc}#sbo-rt-content thead{font-family:sans-serif;font-weight:bold}#sbo-rt-content td,#sbo-rt-content th{display:table-cell;padding:.3em;text-align:left;vertical-align:top;font-size:80%}#sbo-rt-content th{vertical-align:bottom}#sbo-rt-content div.informaltable table{margin:10px auto !important}#sbo-rt-content div.informaltable table tr{border-bottom:none}#sbo-rt-content div.informaltable table tr:nth-of-type(even){background-color:transparent}#sbo-rt-content div.informaltable td,#sbo-rt-content div.informaltable th{border:#9d9d9d 1px solid}#sbo-rt-content div.table-title,#sbo-rt-content table caption{font-weight:normal;font-style:italic;font-family:serif;font-size:1em;margin:10px 0 10px 0 !important;padding:0;page-break-after:avoid;text-align:left !important}#sbo-rt-content table code{font-size:smaller;word-break:break-all}#sbo-rt-content table.border tbody&gt;tr:last-child&gt;td{border-bottom:transparent}#sbo-rt-content div.equation,#sbo-rt-content div[data-type="equation"]{margin:10px 0 15px 0 !important}#sbo-rt-content div.equation-title,#sbo-rt-content div[data-type="equation"] h5{font-style:italic;font-weight:normal;font-family:serif !important;font-size:90%;margin:20px 0 10px 0 !important;page-break-after:avoid}#sbo-rt-content div.equation-contents{margin-left:20px}#sbo-rt-content div[data-type="equation"] math{font-size:calc(.35em + 1vw)}#sbo-rt-content span.inlinemediaobject{height:.85em;display:inline-block;margin-bottom:.2em}#sbo-rt-content span.inlinemediaobject img{margin:0;height:.85em}#sbo-rt-content div.informalequation{margin:20px 0 20px 20px;width:75%}#sbo-rt-content div.informalequation img{width:75%}#sbo-rt-content div.index{text-indent:0}#sbo-rt-content div.index h3{padding:.25em;margin-top:1em !important;background-color:#F0F0F0}#sbo-rt-content div.index li{line-height:130%;list-style-type:none}#sbo-rt-content div.index a.indexterm{color:#8e0012 !important}#sbo-rt-content div.index ul{margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.index ul ul{margin-left:2em !important;margin-top:0 !important}#sbo-rt-content code.boolean,#sbo-rt-content .navy{color:rgb(0,0,128);}#sbo-rt-content code.character,#sbo-rt-content .olive{color:rgb(128,128,0);}#sbo-rt-content code.comment,#sbo-rt-content .blue{color:rgb(0,0,255);}#sbo-rt-content code.conditional,#sbo-rt-content .limegreen{color:rgb(50,205,50);}#sbo-rt-content code.constant,#sbo-rt-content .darkorange{color:rgb(255,140,0);}#sbo-rt-content code.debug,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.define,#sbo-rt-content .darkgoldenrod,#sbo-rt-content .gold{color:rgb(184,134,11);}#sbo-rt-content code.delimiter,#sbo-rt-content .dimgray{color:rgb(105,105,105);}#sbo-rt-content code.error,#sbo-rt-content .red{color:rgb(255,0,0);}#sbo-rt-content code.exception,#sbo-rt-content .salmon{color:rgb(250,128,11);}#sbo-rt-content code.float,#sbo-rt-content .steelblue{color:rgb(70,130,180);}#sbo-rt-content pre code.function,#sbo-rt-content .green{color:rgb(0,128,0);}#sbo-rt-content code.identifier,#sbo-rt-content .royalblue{color:rgb(65,105,225);}#sbo-rt-content code.ignore,#sbo-rt-content .gray{color:rgb(128,128,128);}#sbo-rt-content code.include,#sbo-rt-content .purple{color:rgb(128,0,128);}#sbo-rt-content code.keyword,#sbo-rt-content .sienna{color:rgb(160,82,45);}#sbo-rt-content code.label,#sbo-rt-content .deeppink{color:rgb(255,20,147);}#sbo-rt-content code.macro,#sbo-rt-content .orangered{color:rgb(255,69,0);}#sbo-rt-content code.number,#sbo-rt-content .brown{color:rgb(165,42,42);}#sbo-rt-content code.operator,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.preCondit,#sbo-rt-content .teal{color:rgb(0,128,128);}#sbo-rt-content code.preProc,#sbo-rt-content .fuschia{color:rgb(255,0,255);}#sbo-rt-content code.repeat,#sbo-rt-content .indigo{color:rgb(75,0,130);}#sbo-rt-content code.special,#sbo-rt-content .saddlebrown{color:rgb(139,69,19);}#sbo-rt-content code.specialchar,#sbo-rt-content .magenta{color:rgb(255,0,255);}#sbo-rt-content code.specialcomment,#sbo-rt-content .seagreen{color:rgb(46,139,87);}#sbo-rt-content code.statement,#sbo-rt-content .forestgreen{color:rgb(34,139,34);}#sbo-rt-content code.storageclass,#sbo-rt-content .plum{color:rgb(221,160,221);}#sbo-rt-content code.string,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.structure,#sbo-rt-content .chocolate{color:rgb(210,106,30);}#sbo-rt-content code.tag,#sbo-rt-content .darkcyan{color:rgb(0,139,139);}#sbo-rt-content code.todo,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.type,#sbo-rt-content .mediumslateblue{color:rgb(123,104,238);}#sbo-rt-content code.typedef,#sbo-rt-content .darkgreen{color:rgb(0,100,0);}#sbo-rt-content code.underlined{text-decoration:underline;}#sbo-rt-content pre code.hll{background-color:#ffc}#sbo-rt-content pre code.c{color:#09F;font-style:italic}#sbo-rt-content pre code.err{color:#A00}#sbo-rt-content pre code.k{color:#069;font-weight:bold}#sbo-rt-content pre code.o{color:#555}#sbo-rt-content pre code.cm{color:#35586C;font-style:italic}#sbo-rt-content pre code.cp{color:#099}#sbo-rt-content pre code.c1{color:#35586C;font-style:italic}#sbo-rt-content pre code.cs{color:#35586C;font-weight:bold;font-style:italic}#sbo-rt-content pre code.gd{background-color:#FCC}#sbo-rt-content pre code.ge{font-style:italic}#sbo-rt-content pre code.gr{color:#F00}#sbo-rt-content pre code.gh{color:#030;font-weight:bold}#sbo-rt-content pre code.gi{background-color:#CFC}#sbo-rt-content pre code.go{color:#000}#sbo-rt-content pre code.gp{color:#009;font-weight:bold}#sbo-rt-content pre code.gs{font-weight:bold}#sbo-rt-content pre code.gu{color:#030;font-weight:bold}#sbo-rt-content pre code.gt{color:#9C6}#sbo-rt-content pre code.kc{color:#069;font-weight:bold}#sbo-rt-content pre code.kd{color:#069;font-weight:bold}#sbo-rt-content pre code.kn{color:#069;font-weight:bold}#sbo-rt-content pre code.kp{color:#069}#sbo-rt-content pre code.kr{color:#069;font-weight:bold}#sbo-rt-content pre code.kt{color:#078;font-weight:bold}#sbo-rt-content pre code.m{color:#F60}#sbo-rt-content pre code.s{color:#C30}#sbo-rt-content pre code.na{color:#309}#sbo-rt-content pre code.nb{color:#366}#sbo-rt-content pre code.nc{color:#0A8;font-weight:bold}#sbo-rt-content pre code.no{color:#360}#sbo-rt-content pre code.nd{color:#99F}#sbo-rt-content pre code.ni{color:#999;font-weight:bold}#sbo-rt-content pre code.ne{color:#C00;font-weight:bold}#sbo-rt-content pre code.nf{color:#C0F}#sbo-rt-content pre code.nl{color:#99F}#sbo-rt-content pre code.nn{color:#0CF;font-weight:bold}#sbo-rt-content pre code.nt{color:#309;font-weight:bold}#sbo-rt-content pre code.nv{color:#033}#sbo-rt-content pre code.ow{color:#000;font-weight:bold}#sbo-rt-content pre code.w{color:#bbb}#sbo-rt-content pre code.mf{color:#F60}#sbo-rt-content pre code.mh{color:#F60}#sbo-rt-content pre code.mi{color:#F60}#sbo-rt-content pre code.mo{color:#F60}#sbo-rt-content pre code.sb{color:#C30}#sbo-rt-content pre code.sc{color:#C30}#sbo-rt-content pre code.sd{color:#C30;font-style:italic}#sbo-rt-content pre code.s2{color:#C30}#sbo-rt-content pre code.se{color:#C30;font-weight:bold}#sbo-rt-content pre code.sh{color:#C30}#sbo-rt-content pre code.si{color:#A00}#sbo-rt-content pre code.sx{color:#C30}#sbo-rt-content pre code.sr{color:#3AA}#sbo-rt-content pre code.s1{color:#C30}#sbo-rt-content pre code.ss{color:#A60}#sbo-rt-content pre code.bp{color:#366}#sbo-rt-content pre code.vc{color:#033}#sbo-rt-content pre code.vg{color:#033}#sbo-rt-content pre code.vi{color:#033}#sbo-rt-content pre code.il{color:#F60}#sbo-rt-content pre code.g{color:#050}#sbo-rt-content pre code.l{color:#C60}#sbo-rt-content pre code.l{color:#F90}#sbo-rt-content pre code.n{color:#008}#sbo-rt-content pre code.nx{color:#008}#sbo-rt-content pre code.py{color:#96F}#sbo-rt-content pre code.p{color:#000}#sbo-rt-content pre code.x{color:#F06}#sbo-rt-content div.blockquote_sampler_toc{width:95%;margin:5px 5px 5px 10px !important}#sbo-rt-content div{font-family:serif;text-align:left}#sbo-rt-content .gray-background,#sbo-rt-content .reverse-video{background:#2E2E2E;color:#FFF}#sbo-rt-content .light-gray-background{background:#A0A0A0}#sbo-rt-content .preserve-whitespace{white-space:pre-wrap}#sbo-rt-content pre.break-code,#sbo-rt-content code.break-code,#sbo-rt-content .break-code pre,#sbo-rt-content .break-code code{word-break:break-all}#sbo-rt-content span.gray{color:#4C4C4C}#sbo-rt-content .width-10,#sbo-rt-content figure.width-10 img{width:10% !important}#sbo-rt-content .width-20,#sbo-rt-content figure.width-20 img{width:20% !important}#sbo-rt-content .width-30,#sbo-rt-content figure.width-30 img{width:30% !important}#sbo-rt-content .width-40,#sbo-rt-content figure.width-40 img{width:40% !important}#sbo-rt-content .width-50,#sbo-rt-content figure.width-50 img{width:50% !important}#sbo-rt-content .width-60,#sbo-rt-content figure.width-60 img{width:60% !important}#sbo-rt-content .width-70,#sbo-rt-content figure.width-70 img{width:70% !important}#sbo-rt-content .width-80,#sbo-rt-content figure.width-80 img{width:80% !important}#sbo-rt-content .width-90,#sbo-rt-content figure.width-90 img{width:90% !important}#sbo-rt-content .width-full,#sbo-rt-content .width-100{width:100% !important}#sbo-rt-content .sc{text-transform:none !important}#sbo-rt-content .right{float:none !important}#sbo-rt-content a.totri-footnote{padding:0 !important}#sbo-rt-content figure.width-10,#sbo-rt-content figure.width-20,#sbo-rt-content figure.width-30,#sbo-rt-content figure.width-40,#sbo-rt-content figure.width-50,#sbo-rt-content figure.width-60,#sbo-rt-content figure.width-70,#sbo-rt-content figure.width-80,#sbo-rt-content figure.width-90{width:auto !important}#sbo-rt-content p img,#sbo-rt-content pre img{height:1em;width:1em}#sbo-rt-content .tablerule td{border-bottom:.25pt solid black !important}
    </style>
<style type="text/css" id="font-styles">#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: &lt;%= font_size %&gt; !important; }</style>
<style type="text/css" id="font-family">#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: &lt;%= font_family %&gt; !important; }</style>
<style type="text/css" id="column-width">#sbo-rt-content { max-width: &lt;%= column_width %&gt;% !important; margin: 0 auto !important; }</style>

<style type="text/css">body{margin:1em;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}body{background-color:transparent!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Asynchronous JavaScript"><div class="chapter" id="async">
<h1><span class="label">Chapter 13. </span>Asynchronous JavaScript</h1>


<p>Some<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="definition of term" id="idm46198519760376"/> computer programs, such as scientific simulations and machine
learning models, are compute-bound: they run continuously, without
pause, until they have computed their result. Most real-world computer
programs, however, are significantly <em>asynchronous</em>. This means that
they often have to stop computing while waiting for data to arrive or
for some event to occur. JavaScript<a data-type="indexterm" data-primary="event-driven programming model" data-secondary="definition of term" id="idm46198519758488"/><a data-type="indexterm" data-primary="event-driven programming model" id="idm46198519757496"/> programs in a web browser are
typically <em>event-driven</em>, meaning that they wait for the user to click
or tap before they actually do anything. And JavaScript-based servers
typically wait for client requests to arrive over the network before
they do anything.</p>

<p>This<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="JavaScript support for" id="idm46198519755368"/> kind of asynchronous programming is commonplace in JavaScript, and
this chapter documents three important language features that help
make it easier to work with asynchronous code. Promises, new in
ES6, are objects that represent the not-yet-available result
of an asynchronous operation. The<a data-type="indexterm" data-primary="ES2017, async and await keywords" id="idm46198519753960"/> keywords <code>async</code> and <code>await</code> were
introduced in ES2017 and provide new syntax that simplifies
asynchronous programming by allowing you to structure your Promise-based
code as if it was synchronous. Finally, asynchronous iterators and the
<code>for/await</code> loop were introduced in ES2018 and allow you to
work with streams of asynchronous events using simple loops that
appear synchronous.</p>

<p>Ironically, even though JavaScript provides these powerful features
for working with asynchronous code, there are no features of the core
language that are themselves asynchronous. In order to demonstrate
Promises, <code>async</code>, <code>await</code>, and <code>for/await</code>, therefore, we will first take a detour into client-side and server-side JavaScript to
explain some of the asynchronous features of web browsers and Node.
(You can learn more about client-side and server-side JavaScript in
Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch15.xhtml#clientside">15</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch16.xhtml#serverside">16</a>.)</p>






<section data-type="sect1" data-pdf-bookmark="13.1 Asynchronous Programming with Callbacks"><div class="sect1" id="async-callbacks">
<h1>13.1 Asynchronous Programming with Callbacks</h1>

<p>At<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="definition of term" id="idm46198519744856"/><a data-type="indexterm" data-primary="callbacks" data-secondary="definition of term" id="idm46198519743560"/> its most fundamental level, asynchronous programming in JavaScript
is done with <em>callbacks</em>. A callback is a function that you write and
then pass to some other function. That other function then invokes
(“calls back”) your function when some condition is met or some
(asynchronous) event occurs. The invocation of the callback function
you provide notifies you of the condition or event, and sometimes, the
invocation will include function arguments that provide additional
details. This is easier to understand with some concrete examples, and
the subsections that follow demonstrate various forms of
callback-based asynchronous programming using both client-side
JavaScript and Node.</p>








<section data-type="sect2" data-pdf-bookmark="13.1.1 Timers"><div class="sect2" id="async-timers">
<h2>13.1.1 Timers</h2>

<p>One<a data-type="indexterm" data-primary="timers" id="idm46198519739304"/><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="timers" id="idm46198519738568"/><a data-type="indexterm" data-primary="callbacks" data-secondary="timers" id="idm46198519737384"/> of the simplest kinds of asynchrony is when you want to run some
code after a certain amount of time has elapsed. As we saw in
<a data-type="xref" href="ch11.xhtml#timerapi">§11.10</a>, you<a data-type="indexterm" data-primary="setTimeout() function" id="idm46198519735368"/> can do this with the <code>setTimeout()</code> function:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">setTimeout</code><code class="p">(</code><code class="nx">checkForUpdates</code><code class="p">,</code> <code class="mi">60000</code><code class="p">);</code></pre>

<p>The first argument to <code>setTimeout()</code>
is a function and the second is a time interval measured in
milliseconds. In the preceding code, a hypothetical <code>checkForUpdates()</code>
function will be called 60,000 milliseconds (1 minute) after the
<code>setTimeout()</code> call. <code>checkForUpdates()</code> is a callback function that
your program might define, and <code>setTimeout()</code> is the function that you
invoke to register your callback function and specify under what
asynchronous conditions it should be invoked.</p>

<p><code>setTimeout()</code> calls the specified callback function one time, passing
no arguments, and then forgets about it. If you are writing a function
that really does check for updates, you probably want it to run
repeatedly. You can do this by using <span class="keep-together"><code>setInterval()</code></span> instead of
<code>setTimeout()</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Call checkForUpdates in one minute and then again every minute after that</code>
<code class="kd">let</code> <code class="nx">updateIntervalId</code> <code class="o">=</code> <code class="nx">setInterval</code><code class="p">(</code><code class="nx">checkForUpdates</code><code class="p">,</code> <code class="mi">60000</code><code class="p">);</code>

<code class="c1">// setInterval() returns a value that we can use to stop the repeated</code>
<code class="c1">// invocations by calling clearInterval(). (Similarly, setTimeout()</code>
<code class="c1">// returns a value that you can pass to clearTimeout())</code>
<code class="kd">function</code> <code class="nx">stopCheckingForUpdates</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">clearInterval</code><code class="p">(</code><code class="nx">updateIntervalId</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="13.1.2 Events"><div class="sect2" id="async-events">
<h2>13.1.2 Events</h2>

<p>Client-side<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="events" id="idm46198519710680"/><a data-type="indexterm" data-primary="callbacks" data-secondary="events" id="idm46198519634856"/><a data-type="indexterm" data-primary="web browser host environment" data-secondary="asynchronous APIs" id="idm46198519633880"/> JavaScript programs are almost universally event driven:
rather than running some kind of predetermined computation, they
typically wait for the user to do something and then respond to the
user’s actions. The web browser generates an <em>event</em> when the user
presses a key on the keyboard, moves the mouse, clicks a mouse button,
or touches a touchscreen device. Event-driven JavaScript programs
register callback functions for specified types of events in specified
contexts, and the web browser invokes those functions whenever the
specified events occur. These<a data-type="indexterm" data-primary="event listeners" id="idm46198519631864"/> callback functions are called <em>event
handlers</em> or <em>event listeners</em>, and they are registered with
<span class="keep-together"><code>addEventListener()</code>:</span></p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Ask the web browser to return an object representing the HTML</code>
<code class="c1">// &lt;button&gt; element that matches this CSS selector</code>
<code class="kd">let</code> <code class="nx">okay</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">'#confirmUpdateDialog button.okay'</code><code class="p">);</code>

<code class="c1">// Now register a callback function to be invoked when the user</code>
<code class="c1">// clicks on that button.</code>
<code class="nx">okay</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'click'</code><code class="p">,</code> <code class="nx">applyUpdate</code><code class="p">);</code></pre>

<p>In this example, <code>applyUpdate()</code> is a hypothetical callback function
that we assume is implemented somewhere else. The call to
<code>document.querySelector()</code> returns an object that represents a single
specified element in the web page. We call <code>addEventListener()</code> on that element to register our callback. Then the first argument to <code>addEventListener()</code> is a string that
specifies the kind of event we’re interested in—a mouse click or
touchscreen tap, in this case. If the user clicks or taps on that
specific element of the web page, then the browser will invoke our
<code>applyUpdate()</code> callback function, passing an object that includes
details (such as the time and the mouse pointer coordinates) about
the event.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.1.3 Network Events"><div class="sect2" id="async-network">
<h2>13.1.3 Network Events</h2>

<p>Another<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="network events" id="idm46198519587992"/><a data-type="indexterm" data-primary="callbacks" data-secondary="network events" id="idm46198519586744"/><a data-type="indexterm" data-primary="network events" id="idm46198519585800"/> common source of asynchrony in JavaScript programming is
network requests. JavaScript running in the browser can fetch data
from a web server with code like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">getCurrentVersionNumber</code><code class="p">(</code><code class="nx">versionCallback</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Note callback argument</code>
    <code class="c1">// Make a scripted HTTP request to a backend version API</code>
    <code class="kd">let</code> <code class="nx">request</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">XMLHttpRequest</code><code class="p">();</code>
    <code class="nx">request</code><code class="p">.</code><code class="nx">open</code><code class="p">(</code><code class="s2">"GET"</code><code class="p">,</code> <code class="s2">"http://www.example.com/api/version"</code><code class="p">);</code>
    <code class="nx">request</code><code class="p">.</code><code class="nx">send</code><code class="p">();</code>

    <code class="c1">// Register a callback that will be invoked when the response arrives</code>
    <code class="nx">request</code><code class="p">.</code><code class="nx">onload</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">request</code><code class="p">.</code><code class="nx">status</code> <code class="o">===</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If HTTP status is good, get version number and call callback.</code>
            <code class="kd">let</code> <code class="nx">currentVersion</code> <code class="o">=</code> <code class="nb">parseFloat</code><code class="p">(</code><code class="nx">request</code><code class="p">.</code><code class="nx">responseText</code><code class="p">);</code>
            <code class="nx">versionCallback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">currentVersion</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// Otherwise report an error to the callback</code>
            <code class="nx">versionCallback</code><code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusText</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">};</code>
    <code class="c1">// Register another callback that will be invoked for network errors</code>
    <code class="nx">request</code><code class="p">.</code><code class="nx">onerror</code> <code class="o">=</code> <code class="nx">request</code><code class="p">.</code><code class="nx">ontimeout</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">versionCallback</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">type</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
    <code class="p">};</code>
<code class="p">}</code></pre>

<p>Client-side<a data-type="indexterm" data-primary="fetch() function" id="idm46198519582216"/> JavaScript code can use the XMLHttpRequest class plus
callback functions to make HTTP requests and asynchronously handle the
server’s response when it arrives.<sup><a data-type="noteref" id="idm46198519434968-marker" href="ch13.xhtml#idm46198519434968">1</a></sup> The <code>getCurrentVersionNumber()</code> function
defined here (we can imagine that it is used by the hypothetical
<code>checkForUpdates()</code> function we discussed in <a data-type="xref" href="#async-timers">§13.1.1</a>) makes an HTTP
request and defines event handlers that will be invoked when the
server’s response is received or when a timeout or other error causes
the request to fail.</p>

<p>Notice that the code example above does not call <code>addEventListener()</code> as our
previous example did. For most web APIs (including this one), event
handlers can be defined by invoking <code>addEventListener()</code> on the object
generating the event and passing the name of the event of interest
along with the callback function. Typically, though, you can also
register a single event listener by assigning it directly to a property of
the object. That is what we do in this example code, assigning
functions to the <code>onload</code>, <code>onerror</code>, and <code>ontimeout</code> properties. By
convention, event listener properties like these always have names
that begin with <em>on</em>. <code>addEventListener()</code> is the more flexible
technique because it allows for multiple event handlers. But in cases
where you are sure that no other code will need to register a listener
for the same object and event type, it can be simpler to simply set
the appropriate property to your callback.</p>

<p>Another thing to note about the <code>getCurrentVersionNumber()</code> function
in this example code is that, because it makes an asynchronous request, it cannot
synchronously return the value (the current version number) that the
caller is interested in. Instead, the caller passes a callback
function, which is invoked when the result is ready or when an error
occurs. In this case, the caller supplies a callback function that
expects two arguments. If the XMLHttpRequest works correctly, then
<code>getCurrentVersionNumber()</code> invokes the callback with a <code>null</code> first
argument and the version number as the second argument. Or, if an
error occurs, then <code>getCurrentVersionNumber()</code> invokes the callback
with error details in the first argument and <code>null</code> as the second
argument.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.1.4 Callbacks and Events in Node"><div class="sect2" id="async-node-callbacks">
<h2>13.1.4 Callbacks and Events in Node</h2>

<p>The<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="callbacks and events in Node" id="idm46198519421592"/><a data-type="indexterm" data-primary="callbacks" data-secondary="callbacks and events in Node" id="idm46198519420280"/><a data-type="indexterm" data-primary="Node" data-secondary="callbacks and events in" id="idm46198519419320"/> Node.js server-side JavaScript environment is deeply asynchronous
and defines many APIs that use callbacks and events. The default API
for reading the contents of a file, for example, is asynchronous and
invokes a callback function when the contents of the file have been
read:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code> <code class="c1">// The "fs" module has filesystem-related APIs</code>
<code class="kd">let</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>           <code class="c1">// An object to hold options for our program</code>
    <code class="c1">// default options would go here</code>
<code class="p">};</code>

<code class="c1">// Read a configuration file, then call the callback function</code>
<code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"config.json"</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">text</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// If there was an error, display a warning, but continue</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="s2">"Could not read config file:"</code><code class="p">,</code> <code class="nx">err</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="c1">// Otherwise, parse the file contents and assign to the options object</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">options</code><code class="p">,</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">));</code>
    <code class="p">}</code>

    <code class="c1">// In either case, we can now start running the program</code>
    <code class="nx">startProgram</code><code class="p">(</code><code class="nx">options</code><code class="p">);</code>
<code class="p">});</code></pre>

<p>Node’s <code>fs.readFile()</code> function takes a two-parameter callback as its
last argument. It reads the specified file asynchronously and then
invokes the callback. If the file was read successfully, it passes the
file contents as the second callback argument. If there was an error,
it passes the error as the first callback argument. In this example, we
express the callback as an arrow function, which is a succinct and
natural syntax for this kind of simple operation.</p>

<p>Node also defines a number of event-based APIs. The following function
shows how to make an HTTP request for the contents of a URL in
Node. It has two layers of asynchronous code handled with event
listeners. Notice that Node uses an <code>on()</code> method to register event
listeners instead of <code>addEventListener()</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">https</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"https"</code><code class="p">);</code>

<code class="c1">// Read the text content of the URL and asynchronously pass it to the callback.</code>
<code class="kd">function</code> <code class="nx">getText</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Start an HTTP GET request for the URL</code>
    <code class="nx">request</code> <code class="o">=</code> <code class="nx">https</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>

    <code class="c1">// Register a function to handle the "response" event.</code>
    <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"response"</code><code class="p">,</code> <code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="c1">// The response event means that response headers have been received</code>
        <code class="kd">let</code> <code class="nx">httpStatus</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code><code class="p">;</code>

        <code class="c1">// The body of the HTTP response has not been received yet.</code>
        <code class="c1">// So we register more event handlers to to be called when it arrives.</code>
        <code class="nx">response</code><code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="s2">"utf-8"</code><code class="p">);</code>  <code class="c1">// We're expecting Unicode text</code>
        <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>                  <code class="c1">// which we will accumulate here.</code>

        <code class="c1">// This event handler is called when a chunk of the body is ready</code>
        <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="nx">chunk</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">body</code> <code class="o">+=</code> <code class="nx">chunk</code><code class="p">;</code> <code class="p">});</code>

        <code class="c1">// This event handler is called when the response is complete</code>
        <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">httpStatus</code> <code class="o">===</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>   <code class="c1">// If the HTTP response was good</code>
                <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">body</code><code class="p">);</code>   <code class="c1">// Pass response body to the callback</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>                    <code class="c1">// Otherwise pass an error</code>
                <code class="nx">callback</code><code class="p">(</code><code class="nx">httpStatus</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">});</code>
    <code class="p">});</code>

    <code class="c1">// We also register an event handler for lower-level network errors</code>
    <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">callback</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="13.2 Promises"><div class="sect1" id="async-promises">
<h1>13.2 Promises</h1>

<p>Now<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="overview of" id="idm46198519305064"/><a data-type="indexterm" data-primary="Promises" data-secondary="overview of" id="idm46198519134856"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="overview of" id="idm46198519133912"/> that we’ve seen examples of callback and event-based asynchronous
programming in client-side and server-side JavaScript environments, we
can introduce <em>Promises</em>, a core language feature designed to simplify
asynchronous programming.</p>

<p>A Promise is an object that represents the result of an asynchronous
computation. That result may or may not be ready yet, and the Promise
API is intentionally vague about this: there is no way to
synchronously get the value of a Promise; you can only ask the Promise
to call a callback function when the value is ready.  If you are
defining an asynchronous API like the <code>getText()</code> function in the
previous section, but want to make it Promise-based, omit the callback
argument, and instead return a Promise object. The caller can then
register one or more callbacks on this Promise object, and they will be
invoked when the asynchronous computation is done.</p>

<p>So, at the simplest level, Promises are just a different way of working
with callbacks. However, there are practical benefits to using them. One real problem with callback-based asynchronous programming is that
it is common to end up with callbacks inside callbacks inside
callbacks, with lines of code so highly indented that it is difficult
to read. Promises allow this kind of nested callback to be
re-expressed as a more<a data-type="indexterm" data-primary="Promise chains" id="idm46198519129640"/> linear <em>Promise chain</em> that tends to be easier
to read and easier to reason about.</p>

<p>Another problem with callbacks is that they can make handling errors
difficult. If an asynchronous function (or an asynchronously invoked
callback) throws an exception, there is no way for that exception to
propagate back to the initiator of the asynchronous operation. This is
a fundamental fact about asynchronous programming: it breaks exception
handling. The alternative is to meticulously track and propagate
errors with callback arguments and return values, but this is tedious
and difficult to get right. Promises help here by standardizing a way
to handle errors and providing a way for errors to propagate
correctly through a chain of promises.</p>

<p>Note that Promises represent the future results of single asynchronous
computations. They cannot be used to represent repeated asynchronous
computations, however. Later in this chapter, we’ll write a
Promise-based alternative to the <code>setTimeout()</code> function, for
example. But we can’t use Promises to replace <code>setInterval()</code> because
that function invokes a callback function repeatedly, which is
something that Promises are just not designed to do. Similarly, we
could use a Promise instead of the “load” event handler of an
XMLHttpRequest object, since that callback is only ever called
once. But we typically would not use a Promise in place of a “click”
event handler of an HTML button object, since we normally want to
allow the user to click a button multiple times.</p>

<p>The subsections that follow will:</p>

<ul>
<li>
<p>Explain Promise terminology and show basic Promise usage</p>
</li>
<li>
<p>Show how promises can be chained</p>
</li>
<li>
<p>Demonstrate how to create your own Promise-based APIs</p>
</li>
</ul>
<div data-type="important"><h6>Important</h6>
<p>Promises seem simple at first, and the basic use case for
Promises is, in fact, straightforward and simple. But they can become
surprisingly confusing for anything beyond the simplest use cases.
Promises are a powerful idiom for asynchronous programming, but you
need to understand them deeply to use them correctly and
confidently. It is worth taking the time to develop that deep
understanding, however, and I urge you to study this long chapter
<span class="keep-together">carefully.</span></p>
</div>








<section data-type="sect2" data-pdf-bookmark="13.2.1 Using Promises"><div class="sect2" id="async-using-promises">
<h2>13.2.1 Using Promises</h2>

<p>With<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="using" id="APpromusing13"/><a data-type="indexterm" data-primary="Promises" data-secondary="using" id="Puse13"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="using" id="ESpromuse13"/> the advent of Promises in the core JavaScript language, web
browsers have begun to implement Promise-based APIs. In the previous
section, we implemented a <code>getText()</code> function that made an
asynchronous HTTP request and passed the body of the HTTP response to
a specified callback function as a string. Imagine a variant of this
function, <code>getJSON()</code>, which parses the body of the HTTP response as
JSON and returns a Promise instead of accepting a callback
argument. We will implement a <code>getJSON()</code> function later in this
chapter, but for now, let’s look at how we would use this
Promise-returning utility function:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">jsonData</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// This is a callback function that will be asynchronously</code>
    <code class="c1">// invoked with the parsed JSON value when it becomes available.</code>
<code class="p">});</code></pre>

<p><code>getJSON()</code> starts an asynchronous HTTP request for the URL you
specify and then, while that request is pending, it returns a Promise
object. The Promise object defines a <code>then()</code> instance method. Instead
of passing our callback function directly to 
<span class="keep-together"><code>getJSON()</code>,</span> we instead
pass it to the <code>then()</code> method. When the HTTP response arrives, the
body of that response is parsed as JSON, and the resulting parsed
value is passed to the function that we passed to <code>then()</code>.</p>

<p>You can think of the <code>then()</code> method as a callback registration method
like the 
<span class="keep-together"><code>addEventListener()</code></span> method used for registering event
handlers in client-side JavaScript. If you call the <code>then()</code> method of
a Promise object multiple
times, each of the functions you specify will be called when the
promised computation is complete.</p>

<p>Unlike many event listeners, though,
a Promise represents a single computation, and each function
registered with <code>then()</code> will be invoked only once. It is worth noting
that the function you pass to <code>then()</code> is invoked asynchronously, even
if the asynchronous computation is already complete when you call <code>then()</code>.</p>

<p>At<a data-type="indexterm" data-primary=".then() method" data-primary-sortas="then() method" id="idm46198519087592"/> a simple syntactical level, the <code>then()</code> method is the distinctive
feature of Promises, and it is idiomatic to append <code>.then()</code> directly
to the function invocation that returns the Promise, without the
intermediate step of assigning the Promise object to a <span class="keep-together">variable.</span></p>

<p>It is
also idiomatic to name functions that return Promises and functions
that use the results of Promises with verbs, and these idioms lead to
code that is particularly easy to read:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Suppose you have a function like this to display a user profile</code>
<code class="kd">function</code> <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* implementation omitted */</code> <code class="p">}</code>

<code class="c1">// Here's how you might use that function with a Promise.</code>
<code class="c1">// Notice how this line of code reads almost like an English sentence:</code>
<code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayUserProfile</code><code class="p">);</code></pre>










<section data-type="sect3" data-pdf-bookmark="Handling errors with Promises"><div class="sect3" id="async-promises-errors">
<h3>Handling errors with Promises</h3>

<p>Asynchronous<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="error handling with" id="idm46198519039128"/><a data-type="indexterm" data-primary="Promises" data-secondary="error handling with" id="idm46198519037880"/><a data-type="indexterm" data-primary="error handling" data-secondary="using Promises" id="idm46198519036936"/> operations, particularly those that involve networking,
can typically fail in a number of ways, and robust code has to be
written to handle the errors that will inevitably occur.</p>

<p>For Promises,
we can do this by passing a second function to the <code>then()</code> method:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayUserProfile</code><code class="p">,</code> <code class="nx">handleProfileError</code><code class="p">);</code></pre>

<p>A Promise represents the future result of an asynchronous computation
that occurs after the Promise object is created. Because the
computation is performed after the Promise object is returned to us,
there is no way that the computation can traditionally return a value
or throw an exception that we can catch. The functions that we pass to
<code>then()</code> provide alternatives. When a synchronous computation
completes normally, it simply returns its result to its caller. When a
Promise-based asynchronous computation completes normally, it passes
its result to the function that is the first argument to <code>then()</code>.</p>

<p>When something goes wrong in a synchronous computation, it throws an
exception that propagates up the call stack until there is a <code>catch</code>
clause to handle it. When an asynchronous computation runs, its caller
is no longer on the stack, so if something goes wrong, it is simply
not possible to throw an exception back to the caller.</p>

<p>Instead,
Promise-based asynchronous computations pass the exception (typically
as an Error object of some kind, though this is not required) to the
second function passed to <code>then()</code>. So, in the code above, if
<code>getJSON()</code> runs normally, it passes its result to
<code>displayUserProfile()</code>. If there is an error (the user is not logged
in, the server is down, the user’s internet connection dropped, the
request timed out, etc.), then <code>getJSON()</code> passes an Error object to
<code>handleProfileError()</code>.</p>

<p>In practice, it is rare to see two functions passed to <code>then()</code>. There
is a better and more idiomatic way of handling errors when working
with Promises. To understand it, first consider what happens if
<code>getJSON()</code> completes normally but an error occurs in
<span class="keep-together"><code>displayUserProfile()</code>.</span> That callback function is invoked
asynchronously when <code>getJSON()</code> returns, so it is also asynchronous
and cannot meaningfully throw an exception (because there is no code
on the call stack to handle it).</p>

<p>The more idiomatic way to handle errors in this code looks like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayUserProfile</code><code class="p">).</code><code class="k">catch</code><code class="p">(</code><code class="nx">handleProfileError</code><code class="p">);</code></pre>

<p>With this code, a normal result from <code>getJSON()</code> is still passed to
<code>displayUserProfile()</code>, but any error in <code>getJSON()</code> or in
<code>displayUserProfile()</code> (including any exceptions thrown by
<code>displayUserProfile</code>) get passed to <code>handleProfileError()</code>. The
<code>catch()</code> method is just a shorthand for calling <code>then()</code> with a
<code>null</code> first argument and the specified error handler function as the
second argument.</p>

<p>We’ll have more to say about <code>catch()</code> and this error-handling idiom when we discuss Promise chains in the next section.<a data-type="indexterm" data-primary="" data-startref="APpromusing13" id="idm46198518934008"/><a data-type="indexterm" data-primary="" data-startref="Puse13" id="idm46198518933032"/><a data-type="indexterm" data-primary="" data-startref="ESpromuse13" id="idm46198518909128"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="async-promise-terminology">
<h5>Promise Terminology</h5>
<p>Before<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="terminology" id="idm46198518906072"/><a data-type="indexterm" data-primary="Promises" data-secondary="terminology" id="idm46198518904824"/> we discuss Promises further, it is worth pausing to define some
terms. When we are not programming and we talk about human promises, we say
that a promise is “kept” or “broken.” When discussing JavaScript
Promises, the equivalent terms are “fulfilled” and “rejected.” Imagine
that you have called the <code>then()</code> method of a Promise and have passed
two callback functions to it. We say that the promise has been
<em>fulfilled</em> if and when the first callback is called. And we say that
the Promise has been <em>rejected</em> if and when the second callback is
called. If a Promise is neither fulfilled nor rejected, then it is
<em>pending</em>. And once a promise is fulfilled or rejected, we say that it
is <em>settled</em>. Note that a Promise can never be both fulfilled <em>and</em>
rejected. Once a Promise settles, it will never change from fulfilled
to rejected or vice versa.</p>

<p>Remember how we defined Promises at the start of this section: “a
Promise is an object that represents the <em>result</em> of an asynchronous
operation.” It is important to remember that Promises are not just
abstract ways registering callbacks to run when some async code
finishes—they represent the results of that async code. If the async
code runs normally (and the Promise is fulfilled), then that result is
essentially the return value of the code. And if the async code does
not complete normally (and the Promise is rejected), then the result is
an Error object or some other value that the code might have thrown if
it was not asynchronous. Any Promise that has settled has a value
associated with it, and that value will not change. If the Promise is
fulfilled, then the value is a return value that gets passed to any
callback functions registered as the first argument of <code>then()</code>. If
the Promise is rejected, then the value is an error of some sort that
is passed to any callback functions registered with <code>catch()</code> or as
the second argument of <code>then()</code>.</p>

<p>The reason that I want to be precise about Promise terminology is
that Promises can also be <em>resolved</em>. It is
easy to confuse this resolved state with the fulfilled state or with
settled state, but it is not precisely the same as
either. Understanding the resolved state is one of the keys to a deep
understanding of Promises, and I’ll come back to it after we’ve
discussed Promise chains below.</p>
</div></aside>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="13.2.2 Chaining Promises"><div class="sect2" id="async-chaining-promises">
<h2>13.2.2 Chaining Promises</h2>

<p>One<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="chaining Promises" id="APpromchain13"/><a data-type="indexterm" data-primary="Promises" data-secondary="chaining Promises" id="Pchain13"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="chaining Promises" id="ESpromchain13"/><a data-type="indexterm" data-primary="Promise chains" id="pcomchain13"/> of the most important benefits of Promises is that they provide a
natural way to express a sequence of asynchronous operations as a
linear chain of <code>then()</code> method invocations, without having to nest
each operation within the callback of the previous one. Here, for
example, is a hypothetical Promise chain:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="nx">documentURL</code><code class="p">)</code>                      <code class="c1">// Make an HTTP request</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>  <code class="c1">// Ask for the JSON body of the response</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nb">document</code> <code class="o">=&gt;</code> <code class="p">{</code>                 <code class="c1">// When we get the parsed JSON</code>
        <code class="k">return</code> <code class="nx">render</code><code class="p">(</code><code class="nb">document</code><code class="p">);</code>        <code class="c1">// display the document to the user</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">rendered</code> <code class="o">=&gt;</code> <code class="p">{</code>                 <code class="c1">// When we get the rendered document</code>
        <code class="nx">cacheInDatabase</code><code class="p">(</code><code class="nx">rendered</code><code class="p">);</code>      <code class="c1">// cache it in the local database.</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="nx">handle</code><code class="p">(</code><code class="nx">error</code><code class="p">));</code>     <code class="c1">// Handle any errors that occur</code></pre>

<p>This code illustrates how a chain of Promises can make it easy to
express a sequence of asynchronous operations. We’re not going to discuss
this particular Promise chain at all, however. We will continue to explore the idea of using Promise chains to make HTTP requests, however.</p>

<p>Earlier in this chapter, we saw the XMLHttpRequest object used to make
an HTTP request in JavaScript. That strangely named object has an old
and awkward API, and it has largely been replaced by the newer,
Promise-based Fetch API (<a data-type="xref" href="ch15.xhtml#fetch">§15.11.1</a>). In its simplest form, this new
HTTP API is just the function <code>fetch()</code>. You pass it a URL, and it
returns a Promise. That promise is fulfilled when the HTTP response
begins to arrive and the HTTP status and headers are available:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// When the promise resolves, we have status and headers</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code> <code class="o">&amp;&amp;</code>
        <code class="nx">response</code><code class="p">.</code><code class="nx">headers</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"Content-Type"</code><code class="p">)</code> <code class="o">===</code> <code class="s2">"application/json"</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// What can we do here? We don't actually have the response body yet.</code>
    <code class="p">}</code>
<code class="p">});</code></pre>

<p>When the Promise returned by <code>fetch()</code> is fulfilled, it passes a
Response object to the function you passed to its <code>then()</code>
method. This response object gives you access to request status and
headers, and it also defines methods like <code>text()</code> and <code>json()</code>, which
give you access to the body of the response in text and JSON-parsed
forms, respectively. But although the initial Promise is fulfilled,
the body of the response may not yet have arrived. So these <code>text()</code>
and <code>json()</code> methods for accessing the body of the response themselves
return Promises. Here’s a naive way of using <code>fetch()</code> and the
<code>response.json()</code> method to get the body of an HTTP response:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>  <code class="c1">// Ask for the JSON-parsed body</code>
        <code class="c1">// When the body of the response arrives, it will be automatically</code>
        <code class="c1">// parsed as JSON and passed to this function.</code>
        <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">});</code></pre>

<p>This is a naive way to use Promises because we nested them, like
callbacks, which defeats the purpose. The preferred idiom is
to use Promises in a sequential chain with code like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
    <code class="p">});</code></pre>

<p>Let’s look at the method invocations in this code, ignoring the
arguments that are passed to the methods:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">().</code><code class="nx">then</code><code class="p">().</code><code class="nx">then</code><code class="p">()</code></pre>

<p>When<a data-type="indexterm" data-primary=".then() method" data-primary-sortas="then() method" id="idm46198518579272"/> more than one method is invoked in a single expression like this,
we call it a <em>method chain</em>. We know that the <code>fetch()</code> function
returns a Promise object, and we can see that the first <code>.then()</code> in
this chain invokes a method on that returned Promise object. But there
is a second <code>.then()</code> in the chain, which means that the first
invocation of the <code>then()</code> method must itself return a Promise.</p>

<p>Sometimes, when an API is designed to use this kind of method
chaining, there is just a single object, and each method of that object
returns the object itself in order to facilitate chaining. That is not how
Promises work, however. When we write a chain of <code>.then()</code>
invocations, we are not registering multiple callbacks on a single
Promise object. Instead, each invocation of the <code>then()</code> method
returns a new Promise object. That new Promise object is not fulfilled
until the function passed to <code>then()</code> is <span class="keep-together">complete.</span></p>

<p>Let’s return to a simplified form of the original <code>fetch()</code> chain
above. If we define the functions passed to the <code>then()</code> invocations
elsewhere, we might refactor the code to look like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="nx">theURL</code><code class="p">)</code>          <code class="c1">// task 1; returns promise 1</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">callback1</code><code class="p">)</code>   <code class="c1">// task 2; returns promise 2</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">callback2</code><code class="p">);</code>  <code class="c1">// task 3; returns promise 3</code></pre>

<p>Let’s walk through this code in detail:</p>
<ol>
<li>
<p>On the first line, <code>fetch()</code> is invoked with a URL. It initiates an
HTTP GET request for that URL and returns a Promise. We’ll call this
HTTP request “task 1” and we’ll call the Promise “promise 1”.</p>
</li>
<li>
<p>On the second line, we invoke the <code>then()</code> method of promise 1,
passing the <code>callback1</code> function that we want to be invoked when
promise 1 is fulfilled. The <code>then()</code> method stores our callback
somewhere, then returns a new Promise. We’ll call the new Promise
returned at this step “promise 2”, and we’ll say that “task 2” begins
when <code>callback1</code> is invoked.</p>
</li>
<li>
<p>On the third line, we invoke the <code>then()</code> method of promise 2,
passing the <code>callback2</code> function we want invoked when promise 2 is
fulfilled. This <code>then()</code> method remembers our callback and returns yet
another Promise. We’ll say that “task 3” begins when <code>callback2</code> is
invoked. We can call this latest Promise “promise 3”, but we don’t
really need a name for it because we won’t be using it at all.</p>
</li>
<li>
<p>The previous three steps all happen synchronously when the
expression is first executed. Now we have an asynchronous pause while
the HTTP request initiated in step 1 is sent out across the internet.</p>
</li>
<li>
<p>Eventually, the HTTP response starts to arrive. The asynchronous part
of the <code>fetch()</code> call wraps the HTTP status and headers in a Response
object and fulfills promise 1 with that Response object as the value.</p>
</li>
<li>
<p>When promise 1 is fulfilled, its value (the Response object) is
passed to our <code>callback1()</code> function, and task 2
begins. The job of this task, given a Response object as input, is to
obtain the response body as a JSON object.</p>
</li>
<li>
<p>Let’s assume that task 2 completes normally and is able to parse the
body of the HTTP response to produce a JSON object. This JSON object is
used to fulfill promise 2.</p>
</li>
<li>
<p>The value that fulfills promise 2 becomes the input to task 3 when
it is passed to the <code>callback2()</code> function. This third task now
displays the data to the user in some unspecified way. When task 3 is
complete (assuming it completes normally), then promise 3 will be
fulfilled. But because we never did anything with promise 3, nothing
happens when that Promise settles, and the chain of asynchronous
computation ends at this point.<a data-type="indexterm" data-primary="" data-startref="pcomchain13" id="idm46198518537080"/><a data-type="indexterm" data-primary="" data-startref="ESpromchain13" id="idm46198518536216"/><a data-type="indexterm" data-primary="" data-startref="Pchain13" id="idm46198518535272"/><a data-type="indexterm" data-primary="" data-startref="APpromchain13" id="idm46198518534328"/></p>
</li>

</ol>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.2.3 Resolving Promises"><div class="sect2" id="async-resolving-promises">
<h2>13.2.3 Resolving Promises</h2>

<p>While<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="resolving Promises" id="APpresolv13"/><a data-type="indexterm" data-primary="Promises" data-secondary="resolving Promises" id="Presolv13"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="resolving Promises" id="ESpromresol13"/> explaining the URL-fetching Promise chain with the list in the last section,
we talked about promises 1, 2, and 3. But there is actually a fourth
Promise object involved as well, and this brings us to our important
discussion of what it means for a Promise to be “resolved.”</p>

<p>Remember that <code>fetch()</code> returns a Promise object which, when
fulfilled, passes a Response object to the callback function we
register. This Response object has <code>.text()</code>, <code>.json()</code>, and other
methods to request the body of the HTTP response in various forms. But
since the body may not yet have arrived, these methods must return
Promise objects. In the example we’ve been studying, “task 2” calls
the <code>.json()</code> method and returns its value. This is the fourth Promise
object, and it is the return value of the <code>callback1()</code> function.</p>

<p>Let’s rewrite the URL-fetching code one more time in a verbose and
nonidiomatic way that makes the callbacks and promises explicit:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">c1</code><code class="p">(</code><code class="nx">response</code><code class="p">)</code> <code class="p">{</code>               <code class="c1">// callback 1</code>
    <code class="kd">let</code> <code class="nx">p4</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
    <code class="k">return</code> <code class="nx">p4</code><code class="p">;</code>                        <code class="c1">// returns promise 4</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">c2</code><code class="p">(</code><code class="nx">profile</code><code class="p">)</code> <code class="p">{</code>                <code class="c1">// callback 2</code>
    <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">);</code>  <code class="c1">// promise 1, task 1</code>
<code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">c1</code><code class="p">);</code>                 <code class="c1">// promise 2, task 2</code>
<code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="nx">p2</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">c2</code><code class="p">);</code>                 <code class="c1">// promise 3, task 3</code></pre>

<p>In order for Promise chains to work usefully, the output of task 2
must become the input to task 3. And in the example we’re considering
here, the input to task 3 is the body of the URL that was fetched,
parsed as a JSON object. But, as we’ve just discussed, the return
value of callback <code>c1</code> is not a JSON object, but Promise <code>p4</code> for that
JSON object. This seems like a contradiction, but it is not: when <code>p1</code>
is fulfilled, <code>c1</code> is invoked, and task 2 begins. And when <code>p2</code> is
fulfilled, <code>c2</code> is invoked, and task 3 begins. But just because task 2
begins when <code>c1</code> is invoked, it does not mean that task 2 must end
when <code>c1</code> returns. Promises are about managing asynchronous tasks,
after all, and if task 2 is asynchronous (which it is, in this case),
then that task will not be complete by the time the callback returns.</p>

<p>We are now ready to discuss the final detail that you need to
understand to really master Promises. When you pass a callback <code>c</code> to
the <code>then()</code> method, <code>then()</code> returns a Promise <code>p</code> and arranges to
asynchronously invoke <code>c</code> at some later time. The callback performs
some computation and returns a value <code>v</code>. When the callback returns,
<code>p</code> is <em>resolved</em> with the value <code>v</code>. When a Promise is resolved with
a value that is not itself a Promise, it is immediately fulfilled with
that value. So if <code>c</code> returns a non-Promise, that return value becomes
the value of <code>p</code>, <code>p</code> is fulfilled and we are done. But if the return
value <code>v</code> is itself a Promise, then <code>p</code> is <em>resolved but not yet
fulfilled</em>. At this stage, <code>p</code> cannot settle until the Promise <code>v</code> settles. If <code>v</code> is fulfilled, then <code>p</code> will be fulfilled to the same
value. If <code>v</code> is rejected, then <code>p</code> will be rejected for the same
reason. This is what the “resolved” state of a Promise means: the
Promise has become associated with, or “locked onto,” another
Promise. We don’t know yet whether <code>p</code> will be fulfilled or rejected,
but our callback <code>c</code> no longer has any control over that. <code>p</code> is
“resolved” in the sense that its fate now depends entirely on what
happens to Promise <code>v</code>.</p>

<p>Let’s bring this back to our URL-fetching example. When <code>c1</code> returns
<code>p4</code>, <code>p2</code> is resolved. But being resolved is not the same as being
fulfilled, so task 3 does not begin yet. When the full body of the
HTTP response becomes available, then the <code>.json()</code> method can parse
it and use that parsed value to fulfill <code>p4</code>. When <code>p4</code> is fulfilled,
<code>p2</code> is automatically fulfilled as well, with the same parsed JSON
value. At this point, the parsed JSON object is passed to <code>c2</code>, and
task 3 begins.</p>

<p>This can be one of the trickiest parts of JavaScript to understand,
and you may need to read this section more than
once. <a data-type="xref" href="#promise-chain-diagram">Figure 13-1</a> presents the process in visual form
and may help clarify it for you.</p>

<figure><div id="promise-chain-diagram" class="figure">
<img src="Images/js7e_1301.png" alt="js7e 1301" width="1291" height="1242"/>
<h6><span class="label">Figure 13-1. </span>Fetching a URL with Promises</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.2.4 More on Promises and Errors"><div class="sect2" id="async-more-promise-errors">
<h2>13.2.4 More on Promises and Errors</h2>

<p>Earlier<a data-type="indexterm" data-primary="error handling" data-secondary="using Promises" id="idm46198518431224"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="error handling with" id="ESperror13"/><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="error handling with" id="APperror13"/><a data-type="indexterm" data-primary="Promises" data-secondary="error handling with" id="Perrorhand13"/><a data-type="indexterm" data-primary="" data-startref="ESpromresol13" id="idm46198518426008"/><a data-type="indexterm" data-primary="" data-startref="Presolv13" id="idm46198518425064"/><a data-type="indexterm" data-primary="" data-startref="APpresolv13" id="idm46198518424120"/> in the chapter, we saw that you can pass a second callback<a data-type="indexterm" data-primary=".then() method" data-primary-sortas="then() method" id="idm46198518423048"/> function to the <code>.then()</code> method and that this second function will
be invoked if the Promise is rejected. When that happens, the argument
to this second callback function is a value—typically an Error
object—that represents the reason for the rejection. We also learned
that it is uncommon (and even unidiomatic) to pass two callbacks to a
<code>.then()</code> method. Instead, Promise-related errors are typically
handled by adding a <code>.catch()</code> method invocation to a Promise
chain. Now that we have examined Promise chains, we can
return to error handling and discuss it in more detail. To preface the
discussion, I’d like to stress that careful error handling is really
important when doing asynchronous programming. With synchronous code,
if you leave out error-handling code, you’ll at least get an exception
and a stack trace that you can use to figure out what is going
wrong. With asynchronous code, unhandled exceptions will often go
unreported, and errors can occur silently, making them much harder to
debug. The good news is that the <code>.catch()</code> method makes it easy to
handle errors when working with Promises.</p>










<section data-type="sect3" data-pdf-bookmark="The catch and finally methods"><div class="sect3" id="async-promise-catch">
<h3>The catch and finally methods</h3>

<p>The<a data-type="indexterm" data-primary=".catch() method" data-primary-sortas="catch() method" id="catch13"/><a data-type="indexterm" data-primary=".finally() method" data-primary-sortas="finally method" id="finally13"/> <code>.catch()</code> method of a Promise is simply
a shorthand way to call <code>.then()</code> with <code>null</code> as the first argument
and an error-handling callback as the second argument. Given any Promise
<code>p</code> and a callback <code>c</code>, the following two lines are equivalent:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">p</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">c</code><code class="p">);</code>
<code class="nx">p</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code></pre>

<p>The <code>.catch()</code> shorthand is preferred because it is simpler and
because the name matches the <code>catch</code> clause in a <code>try/catch</code> exception-handling statement. As we’ve discussed, normal exceptions don’t work
with asynchronous code. The <code>.catch()</code> method of Promises is an
alternative that does work for asynchronous code. When something goes
wrong in synchronous code, we can speak of an exception “bubbling up
the call stack” until it finds a <code>catch</code> block. With an asynchronous
chain of Promises, the comparable metaphor might be of an error
“trickling down the chain” until it finds a <code>.catch()</code> invocation.</p>

<p>In<a data-type="indexterm" data-primary="ES2018" data-secondary=".finally() method" data-secondary-sortas="finally() method" id="idm46198518345784"/> ES2018, Promise objects also define a <code>.finally()</code> method
whose purpose is similar to the <code>finally</code> clause in a
<code>try/catch/finally</code> statement. If you add a <code>.finally()</code> invocation to
your Promise chain, then the callback you pass to <code>.finally()</code> will be
invoked when the Promise you called it on settles. Your callback will
be invoked if the Promise fulfills or rejects, and it will not be
passed any arguments, so you can’t find out whether it fulfilled or
rejected. But if you need to run some kind of cleanup code (such as
closing open files or network connections) in either case, a
<code>.finally()</code> callback is the ideal way to do that. Like <code>.then()</code> and
<code>.catch()</code>, <code>.finally()</code> returns a new Promise object. The return
value of a <code>.finally()</code> callback is generally ignored, and the Promise
returned by <code>.finally()</code> will typically resolve or reject with the
same value that the Promise that <code>.finally()</code> was invoked on resolves
or rejects with. If a <code>.finally()</code> callback throws an exception,
however, then the Promise returned by <code>.finally()</code> will reject with
that value.</p>

<p>The URL-fetching code that we studied in the previous sections did not do
any error handling. Let’s correct that now with a more realistic
version of the code:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">)</code>    <code class="c1">// Start the HTTP request</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>       <code class="c1">// Call this when status and headers are ready</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>   <code class="c1">// If we got a 404 Not Found or similar error</code>
            <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>      <code class="c1">// Maybe user is logged out; return null profile</code>
        <code class="p">}</code>

        <code class="c1">// Now check the headers to ensure that the server sent us JSON.</code>
        <code class="c1">// If not, our server is broken, and this is a serious error!</code>
        <code class="kd">let</code> <code class="nx">type</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">headers</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"content-type"</code><code class="p">);</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">type</code> <code class="o">!==</code> <code class="s2">"application/json"</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Expected JSON, got </code><code class="si">${</code><code class="nx">type</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="c1">// If we get here, then we got a 2xx status and a JSON content-type</code>
        <code class="c1">// so we can confidently return a Promise for the response</code>
        <code class="c1">// body as a JSON object.</code>
        <code class="k">return</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>        <code class="c1">// Called with the parsed response body or null</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">profile</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code> <code class="c1">// If we got a 404 error above and returned null we end up here</code>
            <code class="nx">displayLoggedOutProfilePage</code><code class="p">();</code>
        <code class="p">}</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">NetworkError</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// fetch() can fail this way if the internet connection is down</code>
            <code class="nx">displayErrorMessage</code><code class="p">(</code><code class="s2">"Check your internet connection."</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">TypeError</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// This happens if we throw TypeError above</code>
            <code class="nx">displayErrorMessage</code><code class="p">(</code><code class="s2">"Something is wrong with our server!"</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// This must be some kind of unanticipated error</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">});</code></pre>

<p>Let’s analyze this code by looking at what happens when things go
wrong. We’ll use the naming scheme we used before: <code>p1</code> is the Promise
returned by the <code>fetch()</code> call. <code>p2</code> is the Promise returned by the
first <code>.then()</code> call, and <code>c1</code> is the callback that we pass to that
<code>.then()</code> call. <code>p3</code> is the Promise returned by the second <code>.then()</code>
call, and <code>c2</code> is the callback we pass to that call. Finally, <code>c3</code> is
the callback that we pass to the <code>.catch()</code> call. (That call returns a
Promise, but we don’t need to refer to it by name.)</p>

<p>The first thing that could fail is the <code>fetch()</code> request itself. If
the network connection is down (or for some other reason an HTTP
request cannot be made), then Promise <code>p1</code> will be rejected with a
NetworkError object. We didn’t pass an error-handling callback
function as the second argument to the <code>.then()</code> call, so <code>p2</code> rejects
as well with the same NetworkError object. (If we had passed an error
handler to that first <code>.then()</code> call, the error handler would be
invoked, and if it returned normally, <code>p2</code> would be resolved and/or
fulfilled with the return value from that handler.) Without a handler,
though, <code>p2</code> is rejected, and then <code>p3</code> is rejected for the same
reason. At this point, the <code>c3</code> error-handling callback is called, and
the NetworkError-specific code within it runs.</p>

<p>Another way our code could fail is if our HTTP request returns a 404
Not Found or another HTTP error. These are valid HTTP responses, so the
<code>fetch()</code> call does not consider them errors. <code>fetch()</code> encapsulates a
404 Not Found in a Response object and fulfills <code>p1</code> with that object,
causing <code>c1</code> to be invoked. Our code in <code>c1</code> checks the <code>ok</code> property
of the Response object to detect that it has not received a normal
HTTP response and handles that case by simply returning
<code>null</code>. Because this return value is not a Promise, it fulfills <code>p2</code>
right away, and <code>c2</code> is invoked with this value. Our code in <code>c2</code>
explicitly checks for and handles falsy values by displaying a
different result to the user. This is a case where we treat an
abnormal condition as a nonerror and handle it without actually using
an error handler.</p>

<p>A more serious error occurs in <code>c1</code> if the we get a normal HTTP
response code but the Content-Type header is not set
appropriately. Our code expects a JSON-formatted response, so if the
server is sending us HTML, XML, or plain text instead, we’re going to
have a problem. <code>c1</code> includes code to check the Content-Type
header. If the header is wrong, it treats this as a nonrecoverable
problem and throws a TypeError. When a callback passed to <code>.then()</code>
(or <code>.catch()</code>) throws a value, the Promise that was the return value
of the <code>.then()</code> call is rejected with that thrown value. In this
case, the code in <code>c1</code> that raises a TypeError causes <code>p2</code> to be
rejected with that TypeError object. Since we did not specify an error
handler for <code>p2</code>, <code>p3</code> will be rejected as well. <code>c2</code> will
not be called, and the TypeError will be passed to <code>c3</code>, which has code
to explicitly check for and handle this type of error.</p>

<p>There are a couple of things worth noting about this code. First,
notice that the error object thrown with a regular, synchronous
<code>throw</code> statement ends up being handled asynchronously with a
<code>.catch()</code> method invocation in a Promise chain. This should make it
clear why this shorthand method is preferred over passing a second
argument to <code>.then()</code>, and also why it is so idiomatic to end Promise
chains with a <code>.catch()</code> call.</p>

<p>Before we leave the topic of error handling, I want to point out that, although it is idiomatic to end every Promise chain with a <code>.catch()</code>
to clean up (or at least log) any errors that occurred in the chain,
it is also perfectly valid to use <code>.catch()</code> elsewhere in a Promise
chain. If one of the stages in your Promise chain can fail with an
error, and if the error is some kind of recoverable error that should
not stop the rest of the chain from running, then you can insert a
<code>.catch()</code> call in the chain, resulting in code that might look like
this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">startAsyncOperation</code><code class="p">()</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStageTwo</code><code class="p">)</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">recoverFromStageTwoError</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStageThree</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStageFour</code><code class="p">)</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">logStageThreeAndFourErrors</code><code class="p">);</code></pre>

<p>Remember that the callback you pass to <code>.catch()</code> will only be invoked
if the callback at a previous stage throws an error. If the callback
returns normally, then the <code>.catch()</code> callback will be skipped, and the
return value of the previous callback will become the input to the
next <code>.then()</code> callback. Also remember that <code>.catch()</code> callbacks are
not just for reporting errors, but for handling and recovering from
errors. Once an error has been passed to a <code>.catch()</code> callback, it
stops propagating down the Promise chain. A <code>.catch()</code> callback can
throw a new error, but if it returns normally, than that return value
is used to resolve and/or fulfill the associated Promise, and the error
stops propagating.</p>

<p>Let’s be concrete about this: in the preceding code example, if
either <code>startAsyncOperation()</code> or <code>doStageTwo()</code> throws an error, then the
<code>recoverFromStageTwoError()</code> function will be invoked. If
<code>recoverFromStageTwoError()</code> returns normally, then its return value
will be passed to <code>doStageThree()</code> and the asynchronous operation
continues normally. On the other hand, if <code>recoverFromStageTwoError()</code>
was unable to recover, it will itself throw an error (or it will
rethrow the error that it was passed). In this case, neither
<code>doStageThree()</code> nor <code>doStageFour()</code> will be invoked, and the error
thrown by <code>recoverFromStageTwoError()</code> would be passed to
<code>logStageThreeAndFourErrors()</code>.</p>

<p>Sometimes, in complex network environments, errors can occur more or
less at random, and it can be appropriate to handle those errors by
simply retrying the asynchronous request. Imagine you’ve written a
Promise-based operation to query a database:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">queryDatabase</code><code class="p">()</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayTable</code><code class="p">)</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">displayDatabaseError</code><code class="p">);</code></pre>

<p>Now suppose that transient network load issues are causing this to
fail about 1% of the time. A simple solution might be to retry the
query with a <code>.catch()</code> call:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">queryDatabase</code><code class="p">()</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">wait</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">queryDatabase</code><code class="p">))</code>  <code class="c1">// On failure, wait and retry</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayTable</code><code class="p">)</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">displayDatabaseError</code><code class="p">);</code></pre>

<p>If the hypothetical failures are truly random, then adding this one
line of code should reduce your error rate from 1% to .01%.<a data-type="indexterm" data-primary="" data-startref="finally13" id="idm46198518061336"/><a data-type="indexterm" data-primary="" data-startref="catch13" id="idm46198518060488"/><a data-type="indexterm" data-primary="" data-startref="ESperror13" id="idm46198517971288"/><a data-type="indexterm" data-primary="" data-startref="APperror13" id="idm46198517970344"/><a data-type="indexterm" data-primary="" data-startref="Perrorhand13" id="idm46198517969400"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="async-promise-return">
<h5>Returning from a Promise Callback</h5>
<p>Let’s<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="returning from Promise callbacks" id="idm46198517966552"/><a data-type="indexterm" data-primary="Promises" data-secondary="returning from Promise callbacks" id="idm46198517964952"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="returning from Promise callbacks" id="idm46198517964040"/> return one last time to the earlier URL-fetching example, and
consider the <code>c1</code> callback that we passed to the first <code>.then()</code>
invocation. Notice that there are three ways that <code>c1</code> can
terminate. It can return normally with the Promise returned by the
<code>.json()</code> call. This causes <code>p2</code> to be resolved, but whether that
Promise is fulfilled or rejected depends on what happens with the
newly returned Promise. <code>c1</code> can also return normally with the value
<code>null</code>, which causes <code>p2</code> to be fulfilled immediately. Finally, <code>c1</code> can
terminate by throwing an error, which causes <code>p2</code> to be
rejected. These are the three possible outcomes for a Promise, and the
code in <code>c1</code> demonstrates how the callback can cause each outcome.</p>

<p>In a Promise chain, the value returned (or thrown) at one stage of the
chain becomes the input to the next stage of the chain, so it is
critical to get this right. In practice, forgetting to return a value
from a callback function is actually a common source of
Promise-related bugs, and this is exacerbated by JavaScript’s arrow
function shortcut syntax. Consider this line of code that we saw earlier:</p>

<pre data-type="programlisting" data-code-language="js"><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">wait</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">queryDatabase</code><code class="p">))</code></pre>

<p>Recall from <a data-type="xref" href="ch08.xhtml#functions">Chapter 8</a> that arrow functions allow a lot of
shortcuts. Since there is exactly one argument (the error value), we
can omit the parentheses. Since the body of the function is a single
expression, we can omit the curly braces around the function body, and
the value of the expression becomes the return value of the
function. Because of these shortcuts, the preceding code is correct. But
consider this innocuous-seeming change:</p>

<pre data-type="programlisting" data-code-language="js"><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">wait</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">queryDatabase</code><code class="p">)</code> <code class="p">})</code></pre>

<p>By adding the curly braces, we no longer get the automatic return. This
function now returns <code>undefined</code> instead of returning a Promise, which
means that the next stage in this Promise chain will be invoked with
<code>undefined</code> as its input rather than the result of the retried
query. It is a subtle error that may not be easy to debug.</p>
</div></aside>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="13.2.5 Promises in Parallel"><div class="sect2" id="async-promises-parallel">
<h2>13.2.5 Promises in Parallel</h2>

<p>We’ve<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="parallel operations" id="idm46198517901544"/><a data-type="indexterm" data-primary="Promises" data-secondary="parallel operations" id="idm46198517900296"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="parallel operations" id="idm46198517899352"/> spent a lot of time talking about Promise chains for
sequentially running the asynchronous steps of a larger asynchronous
operation. Sometimes, though, we want to execute a number of
asynchronous operations in parallel. The<a data-type="indexterm" data-primary="Promise.all() function" id="idm46198517897768"/> function <code>Promise.all()</code> can
do this. <code>Promise.all()</code> takes an array of Promise objects as its
input and returns a Promise. The returned Promise will be rejected if
any of the input Promises are rejected. Otherwise, it will be
fulfilled with an array of the fulfillment values of each of the input
Promises. So, for example, if you want to fetch the text content of
multiple URLs, you could use code like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// We start with an array of URLs</code>
<code class="kr">const</code> <code class="nx">urls</code> <code class="o">=</code> <code class="p">[</code> <code class="cm">/* zero or more URLs here */</code> <code class="p">];</code>
<code class="c1">// And convert it to an array of Promise objects</code>
<code class="nx">promises</code> <code class="o">=</code> <code class="nx">urls</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">url</code> <code class="o">=&gt;</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">.</code><code class="nx">text</code><code class="p">()));</code>
<code class="c1">// Now get a Promise to run all those Promises in parallel</code>
<code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code><code class="nx">promises</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">bodies</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something with the array of strings */</code> <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code></pre>

<p><code>Promise.all()</code> is slightly more flexible than described before. The
input array can contain both Promise objects and non-Promise
values. If an element of the array is not a Promise, it is treated as
if it is the value of an already fulfilled Promise and is simply
copied unchanged into the output array.</p>

<p>The Promise returned by <code>Promise.all()</code> rejects when any of the
input Promises is rejected. This happens immediately upon the first
rejection and can happen while other input Promises are still
pending. In<a data-type="indexterm" data-primary="ES2020" data-secondary="Promise.allSettled()" id="idm46198517785240"/> ES2020, <code>Promise.allSettled()</code> takes an array of input
Promises and returns a Promise, just like <code>Promise.all()</code> does. But
<code>Promise.allSettled()</code> never rejects the returned Promise, and it does
not fulfill that Promise until all of the input Promises have
settled. The Promise resolves to an array of objects, with one object
for each input Promise. Each of these returned objects has a <code>status</code>
property set to “fulfilled” or “rejected.” If the status is
“fulfilled”, then the object will also have a <code>value</code> property that
gives the fulfillment value. And if the status is “rejected”, then the
object will also have a <code>reason</code> property that gives the error or
rejection value of the corresponding Promise:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nb">Promise</code><code class="p">.</code><code class="nx">allSettled</code><code class="p">([</code><code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">reject</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code> <code class="mi">3</code><code class="p">]).</code><code class="nx">then</code><code class="p">(</code><code class="nx">results</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">results</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>  <code class="c1">// =&gt; { status: "fulfilled", value: 1 }</code>
    <code class="nx">results</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>  <code class="c1">// =&gt; { status: "rejected", reason: 2 }</code>
    <code class="nx">results</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>  <code class="c1">// =&gt; { status: "fulfilled", value: 3 }</code>
<code class="p">});</code></pre>

<p>Occasionally, you may want to run a number of Promises at once but may
only care about the value of the first one to fulfill. In that case,
you can use <code>Promise.race()</code> instead of <code>Promise.all()</code>. It returns a
Promise that is fulfilled or rejected when the first of the Promises
in the input array is fulfilled or rejected. (Or, if there are any
non-Promise values in the input array, it simply returns the first of
those.)</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.2.6 Making Promises"><div class="sect2" id="async-making-promises">
<h2>13.2.6 Making Promises</h2>

<p>We’ve<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="making Promises" id="APpmaking13"/><a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" id="Pmake13"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="making Promises" id="ESPmake13"/> used the Promise-returning function <code>fetch()</code> in many of the
previous examples because it is one of the simplest functions built in to web
browsers that returns a Promise. Our discussion of Promises has also
relied on hypothetical Promise-returning functions <code>getJSON()</code> and
<code>wait()</code>. Functions written to return Promises really are quite
useful, and this section shows how you can create your own
Promise-based APIs. In particular, we’ll show implementations of
<code>getJSON()</code> and <code>wait()</code>.</p>










<section data-type="sect3" data-pdf-bookmark="Promises based on other Promises"><div class="sect3" id="idm46198517693784">
<h3>Promises based on other Promises</h3>

<p>It<a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" data-tertiary="based on other Promises" id="idm46198517692168"/> is easy to write a function that returns a Promise if you have some
other Promise-returning function to start with. Given a Promise, you
can always create (and return) a new one by calling <code>.then()</code>. So if
we use the existing <code>fetch()</code> function as a starting point, we can
write <code>getJSON()</code> like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>
<code class="p">}</code></pre>

<p>The code is trivial because the Response object of the <code>fetch()</code> API
has a predefined <code>json()</code> method. The <code>json()</code> method returns a
Promise, which we return from our callback (the callback is an arrow
function with a single-expression body, so the return is implicit), so
the Promise returned by <code>getJSON()</code> resolves to the Promise returned
by <code>response.json()</code>. When that Promise fulfills, the Promise
returned by <code>getJSON()</code> fulfills to the same value. Note that there is
no error handling in this <code>getJSON()</code> implementation. Instead of
checking <code>response.ok</code> and the Content-Type header, we instead just
allow the <code>json()</code> method to reject the Promise it returned with a
SyntaxError if the response body cannot be parsed as JSON.</p>

<p>Let’s write another Promise-returning function, this time using
<code>getJSON()</code> as the source of the initial Promise:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">getHighScore</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">highScore</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>We’re assuming that this function is part of some sort of web-based
game and that the URL “/api/user/profile” returns a JSON-formatted
data structure that includes a <code>highScore</code> property.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Promises based on synchronous values"><div class="sect3" id="idm46198517631560">
<h3>Promises based on synchronous values</h3>

<p>Sometimes, you<a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" data-tertiary="based on synchronous values" id="idm46198517630248"/> may need to implement an existing Promise-based API and
return a Promise from a function, even though the computation
to be performed does not actually require any asynchronous
operations. In that case, the static methods <code>Promise.resolve()</code> and
<code>Promise.reject()</code> will do what you want. <code>Promise.resolve()</code> takes a
value as its single argument and returns a Promise that will
immediately (but asynchronously) be fulfilled to that
value. Similarly, <code>Promise.reject()</code> takes a single argument and
returns a Promise that will be rejected with that value as the
reason. (To be clear: the Promises returned by these static methods
are not already fulfilled or rejected when they are returned, but they
will fulfill or reject immediately after the current synchronous chunk
of code has finished running. Typically, this happens within a few
milliseconds unless there are many pending asynchronous tasks waiting
to run.)</p>

<p>Recall from <a data-type="xref" href="#async-resolving-promises">§13.2.3</a> that a resolved Promise is
not the same thing as a fulfilled Promise. When we call
<code>Promise.resolve()</code>, we typically pass the fulfillment value to create
a Promise object that will very soon fulfill to that value. The method
is not named <code>Promise.fulfill()</code>, however. If you pass a Promise <code>p1</code>
to <code>Promise.resolve()</code>, it will return a new Promise <code>p2</code>, which is
immediately resolved, but which will not be fulfilled or rejected
until <code>p1</code> is fulfilled or rejected.</p>

<p>It is possible, but unusual, to write a Promise-based function where
the value is computed synchronously and returned asynchronously with
<code>Promise.resolve()</code>. It is fairly common, however, to have synchronous
special cases within an asynchronous function, and you can handle
these special cases with <code>Promise.resolve()</code> and
<code>Promise.reject()</code>. In particular, if you detect error conditions
(such as bad argument values) before beginning an asynchronous
operation, you can report that error by returning a Promise created
with <code>Promise.reject()</code>. (You could also just throw an error
synchronously in that case, but that is considered poor form because
then the caller of your function needs to write both a synchronous
<code>catch</code> clause and use an asynchronous <code>.catch()</code> method to handle errors.)
Finally, <code>Promise.resolve()</code> is sometimes useful to create the initial
Promise in a chain of Promises. We’ll see a couple of examples
that use it this way.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Promises from scratch"><div class="sect3" id="async-promises-from-scratch">
<h3>Promises from scratch</h3>

<p>For<a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" data-tertiary="from scratch" id="idm46198517589352"/> both <code>getJSON()</code> and <code>getHighScore()</code>, we started off by calling
an existing function to get an initial Promise, and created and
returned a new Promise by calling the <code>.then()</code> method of that initial
Promise. But what about writing a Promise-returning function when you
can’t use another Promise-returning function as the starting point? In
that case, you use the <code>Promise()</code> constructor to create a new Promise
object that you have complete control over. Here’s how it works: you
invoke the <code>Promise()</code> constructor and pass a function as its only
argument. The function you pass should be written to expect two
parameters, which, by convention, should be named <code>resolve</code> and
<code>reject</code>. The constructor synchronously calls your function with
function arguments for the <code>resolve</code> and <code>reject</code> parameters. After
calling your function, the <code>Promise()</code> constructor returns the newly
created Promise. That returned Promise is under the control of the
function you passed to the constructor. That function should perform
some asynchronous operation and then call the <code>resolve</code> function to
resolve or fulfill the returned Promise or call the <code>reject</code> function
to reject the returned Promise. Your function does not have to be
asynchronous: it can call <code>resolve</code> or <code>reject</code> synchronously, but the
Promise will still be resolved, fulfilled, or rejected asynchronously if
you do this.</p>

<p>It can be hard to understand the functions passed to a function passed
to a constructor by just reading about it, but hopefully some examples
will make this clear. Here’s how to write the Promise-based <code>wait()</code>
function that we used in various examples earlier in the chapter:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">wait</code><code class="p">(</code><code class="nx">duration</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Create and return a new Promise</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// These control the Promise</code>
        <code class="c1">// If the argument is invalid, reject the Promise</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">duration</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Time travel not yet implemented"</code><code class="p">));</code>
        <code class="p">}</code>
        <code class="c1">// Otherwise, wait asynchronously and then resolve the Promise.</code>
        <code class="c1">// setTimeout will invoke resolve() with no arguments, which means</code>
        <code class="c1">// that the Promise will fulfill with the undefined value.</code>
        <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">duration</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">}</code></pre>

<p>Note that the pair of functions that you use to control the fate of a
Promise created with the <code>Promise()</code> constructor are named <code>resolve()</code>
and <code>reject()</code>, not <code>fulfill()</code> and <code>reject()</code>. If you pass a Promise
to <code>resolve()</code>, the returned Promise will resolve to that new
Promise. Often, however, you will pass a non-Promise value,
which fulfills the returned Promise with that value.</p>

<p><a data-type="xref" href="#getJSON-js">Example 13-1</a> is another example of using the <code>Promise()</code> constructor. This one
implements our <code>getJSON()</code> function for use in Node, where the
<code>fetch()</code> API is not built in. Remember that we started this chapter
with a discussion of asynchronous callbacks and events. This example
uses both callbacks and event handlers and is a good demonstration,
therefore, of how we can implement Promise-based APIs on top of other
styles of asynchronous programming.</p>
<div id="getJSON-js" data-type="example">
<h5><span class="label">Example 13-1. </span>An asynchronous getJSON() function</h5>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">http</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"http"</code><code class="p">);</code>

<code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Create and return a new Promise</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="c1">// Start an HTTP GET request for the specified URL</code>
        <code class="nx">request</code> <code class="o">=</code> <code class="nx">http</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// called when response starts</code>
            <code class="c1">// Reject the Promise if the HTTP status is wrong</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code> <code class="o">!==</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`HTTP status </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code><code class="si">}</code><code class="sb">`</code><code class="p">));</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">resume</code><code class="p">();</code>  <code class="c1">// so we don't leak memory</code>
            <code class="p">}</code>
            <code class="c1">// And reject if the response headers are wrong</code>
            <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">headers</code><code class="p">[</code><code class="s2">"content-type"</code><code class="p">]</code> <code class="o">!==</code> <code class="s2">"application/json"</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Invalid content-type"</code><code class="p">));</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">resume</code><code class="p">();</code>  <code class="c1">// don't leak memory</code>
            <code class="p">}</code>
            <code class="k">else</code> <code class="p">{</code>
                <code class="c1">// Otherwise, register events to read the body of the response</code>
                <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="s2">"utf-8"</code><code class="p">);</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="nx">chunk</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">body</code> <code class="o">+=</code> <code class="nx">chunk</code><code class="p">;</code> <code class="p">});</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="c1">// When the response body is complete, try to parse it</code>
                    <code class="k">try</code> <code class="p">{</code>
                        <code class="kd">let</code> <code class="nx">parsed</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
                        <code class="c1">// If it parsed successfully, fulfill the Promise</code>
                        <code class="nx">resolve</code><code class="p">(</code><code class="nx">parsed</code><code class="p">);</code>
                    <code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// If parsing failed, reject the Promise</code>
                        <code class="nx">reject</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">});</code>
            <code class="p">}</code>
        <code class="p">});</code>
        <code class="c1">// We also reject the Promise if the request fails before we</code>
        <code class="c1">// even get a response (such as when the network is down)</code>
        <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
        <code class="p">});</code>
    <code class="p">});</code>
<code class="p">}</code></pre></div>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="13.2.7 Promises in Sequence"><div class="sect2" id="async-promises-sequence">
<h2>13.2.7 Promises in Sequence</h2>

<p><code>Promise.all()</code> makes<a data-type="indexterm" data-primary="" data-startref="APpmaking13" id="idm46198517497304"/><a data-type="indexterm" data-primary="" data-startref="Pmake13" id="idm46198517235352"/><a data-type="indexterm" data-primary="" data-startref="ESPmake13" id="idm46198517234408"/><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="Promises in sequence" id="APpseq13"/><a data-type="indexterm" data-primary="Promises" data-secondary="Promises in sequence" id="Pseq13"/><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="Promises in sequence" id="ESpseq13"/> it easy to run an arbitrary number of Promises
in parallel. And Promise chains make it easy to express a sequence of a
fixed number of Promises. Running an arbitrary number of Promises in
sequence is trickier, however. Suppose, for example, that you have an
array of URLs to fetch, but that to avoid overloading your network,
you want to fetch them one at a time. If the array is of arbitrary
length and unknown content, you can’t write out a Promise chain in
advance, so you need to build one dynamically, with code like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">fetchSequentially</code><code class="p">(</code><code class="nx">urls</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// We'll store the URL bodies here as we fetch them</code>
    <code class="kr">const</code> <code class="nx">bodies</code> <code class="o">=</code> <code class="p">[];</code>

    <code class="c1">// Here's a Promise-returning function that fetches one body</code>
    <code class="kd">function</code> <code class="nx">fetchOne</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">())</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">body</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// We save the body to the array, and we're purposely</code>
                <code class="c1">// omitting a return value here (returning undefined)</code>
                <code class="nx">bodies</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
            <code class="p">});</code>
    <code class="p">}</code>

    <code class="c1">// Start with a Promise that will fulfill right away (with value undefined)</code>
    <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="kc">undefined</code><code class="p">);</code>

    <code class="c1">// Now loop through the desired URLs, building a Promise chain</code>
    <code class="c1">// of arbitrary length, fetching one URL at each stage of the chain</code>
    <code class="k">for</code><code class="p">(</code><code class="nx">url</code> <code class="k">of</code> <code class="nx">urls</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">p</code> <code class="o">=</code> <code class="nx">p</code><code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">fetchOne</code><code class="p">(</code><code class="nx">url</code><code class="p">));</code>
    <code class="p">}</code>

    <code class="c1">// When the last Promise in that chain is fulfilled, then the</code>
    <code class="c1">// bodies array is ready. So let's return a Promise for that</code>
    <code class="c1">// bodies array. Note that we don't include any error handlers:</code>
    <code class="c1">// we want to allow errors to propagate to the caller.</code>
    <code class="k">return</code> <code class="nx">p</code><code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">bodies</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>With this <code>fetchSequentially()</code> function defined, we could fetch the
URLs one at a time with code much like the fetch-in-parallel code we
used earlier to demonstrate <code>Promise.all()</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">fetchSequentially</code><code class="p">(</code><code class="nx">urls</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">bodies</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something with the array of strings */</code> <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code></pre>

<p>The <code>fetchSequentially()</code> function starts by creating a Promise that
will fulfill immediately after it returns. It then builds a long,
linear Promise chain off of that initial Promise and returns the last
Promise in the chain. It is like setting up a row of dominoes and then
knocking the first one over.</p>

<p>There is another (possibly more elegant) approach that we can
take. Rather than creating the Promises in advance, we can have the
callback for each Promise create and return the next Promise. That is,
instead of creating and chaining a bunch of Promises, we instead
create Promises that resolve to other Promises. Rather than creating a
domino-like chain of Promises, we are instead creating a sequence of
Promises nested one inside the other like a set of matryoshka
dolls. With this approach, our code can return the first (outermost)
Promise, knowing that it will eventually fulfill (or reject!) to the
same value that the last (innermost) Promise in the sequence does. The
<code>promiseSequence()</code> function that follows is written to be generic and is not
specific to URL fetching. It is here at the end of our discussion of
Promises because it is complicated. If you’ve read this chapter
carefully, however, I hope you’ll be able to understand how it
works. In particular, note that the nested function inside
<code>promiseSequence()</code> appears to call itself recursively, but because
the “recursive” call is through a <code>then()</code> method, there is not
actually any traditional recursion happening:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// This function takes an array of input values and a "promiseMaker" function.</code>
<code class="c1">// For any input value x in the array, promiseMaker(x) should return a Promise</code>
<code class="c1">// that will fulfill to an output value. This function returns a Promise</code>
<code class="c1">// that fulfills to an array of the computed output values.</code>
<code class="c1">//</code>
<code class="c1">// Rather than creating the Promises all at once and letting them run in</code>
<code class="c1">// parallel, however, promiseSequence() only runs one Promise at a time</code>
<code class="c1">// and does not call promiseMaker() for a value until the previous Promise</code>
<code class="c1">// has fulfilled.</code>
<code class="kd">function</code> <code class="nx">promiseSequence</code><code class="p">(</code><code class="nx">inputs</code><code class="p">,</code> <code class="nx">promiseMaker</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Make a private copy of the array that we can modify</code>
    <code class="nx">inputs</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">inputs</code><code class="p">];</code>

    <code class="c1">// Here's the function that we'll use as a Promise callback</code>
    <code class="c1">// This is the pseudorecursive magic that makes this all work.</code>
    <code class="kd">function</code> <code class="nx">handleNextInput</code><code class="p">(</code><code class="nx">outputs</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">inputs</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If there are no more inputs left, then return the array</code>
            <code class="c1">// of outputs, finally fulfilling this Promise and all the</code>
            <code class="c1">// previous resolved-but-not-fulfilled Promises.</code>
            <code class="k">return</code> <code class="nx">outputs</code><code class="p">;</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// If there are still input values to process, then we'll</code>
            <code class="c1">// return a Promise object, resolving the current Promise</code>
            <code class="c1">// with the future value from a new Promise.</code>
            <code class="kd">let</code> <code class="nx">nextInput</code> <code class="o">=</code> <code class="nx">inputs</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code> <code class="c1">// Get the next input value,</code>
            <code class="k">return</code> <code class="nx">promiseMaker</code><code class="p">(</code><code class="nx">nextInput</code><code class="p">)</code>  <code class="c1">// compute the next output value,</code>
                <code class="c1">// Then create a new outputs array with the new output value</code>
                <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">output</code> <code class="o">=&gt;</code> <code class="nx">outputs</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">output</code><code class="p">))</code>
                <code class="c1">// Then "recurse", passing the new, longer, outputs array</code>
                <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">handleNextInput</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="c1">// Start with a Promise that fulfills to an empty array and use</code>
    <code class="c1">// the function above as its callback.</code>
    <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">([]).</code><code class="nx">then</code><code class="p">(</code><code class="nx">handleNextInput</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This <code>promiseSequence()</code> function is intentionally generic. We can use
it to fetch URLs with code<a data-type="indexterm" data-primary="" data-startref="ESpseq13" id="idm46198517175480"/><a data-type="indexterm" data-primary="" data-startref="Pseq13" id="idm46198516865800"/><a data-type="indexterm" data-primary="" data-startref="APpseq13" id="idm46198516864856"/> like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Given a URL, return a Promise that fulfills to the URL body text</code>
<code class="kd">function</code> <code class="nx">fetchBody</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">.</code><code class="nx">text</code><code class="p">());</code> <code class="p">}</code>
<code class="c1">// Use it to sequentially fetch a bunch of URL bodies</code>
<code class="nx">promiseSequence</code><code class="p">(</code><code class="nx">urls</code><code class="p">,</code> <code class="nx">fetchBody</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">bodies</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something with the array of strings */</code> <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">);</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="13.3 async and await"><div class="sect1" id="async-await">
<h1>13.3 async and await</h1>

<p>ES2017<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="async and await keywords" id="APasync13"/><a data-type="indexterm" data-primary="async keyword" id="async13"/><a data-type="indexterm" data-primary="await keyword" id="await13"/><a data-type="indexterm" data-primary="keywords" data-secondary="async keyword" id="Kasync13"/><a data-type="indexterm" data-primary="keywords" data-secondary="await keyword" id="Kawait13"/><a data-type="indexterm" data-primary="ES2017, async and await keywords" id="ESasync13"/> introduces two new keywords—<code>async</code> and <code>await</code>—that
represent a paradigm shift in asynchronous JavaScript
programming. These new keywords dramatically simplify the use of
Promises and allow us to write Promise-based, asynchronous code that
looks like synchronous code that blocks while waiting for network
responses or other asynchronous events. Although it is still important
to understand how <span class="keep-together">Promises</span> work, much of their complexity (and
sometimes even their very presence!) vanishes when you use them with
<code>async</code> and <code>await</code>.</p>

<p>As we discussed earlier in the chapter, asynchronous code can’t
return a value or throw an exception the way that regular synchronous
code can. And this is why Promises are designed the way the are. The
value of a fulfilled Promise is like the return value of a synchronous
function. And the value of a rejected Promise is like a value thrown
by a synchronous function. This latter similarity is made explicit by
the naming of the <code>.catch()</code> method. <code>async</code> and <code>await</code> take
efficient, Promise-based code and hide the Promises so that your
asynchronous code can be as easy to read and as easy to reason about
as inefficient, blocking, synchronous code.</p>








<section data-type="sect2" data-pdf-bookmark="13.3.1 await Expressions"><div class="sect2" id="async-await-expressions">
<h2>13.3.1 await Expressions</h2>

<p>The <code>await</code> keyword takes a Promise and turns it back into a return
value or a thrown exception. Given a Promise object <code>p</code>, the
expression <code>await p</code> waits until <code>p</code> settles. If <code>p</code> fulfills, then
the value of <code>await p</code> is the fulfillment value of <code>p</code>. On the other
hand, if <code>p</code> is rejected, then the <code>await p</code> expression throws the
rejection value of <code>p</code>. We don’t usually use <code>await</code> with a variable
that holds a Promise; instead, we use it before the invocation of a
function that returns a Promise:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">);</code>
<code class="kd">let</code> <code class="nx">profile</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code></pre>

<p>It is critical to understand right away that the <code>await</code> keyword does
not cause your program to block and literally do nothing until the
specified Promise settles. The code remains asynchronous, and the
<code>await</code> simply disguises this fact. This means that <em>any code that uses</em>
<code>await</code> <em>is itself asynchronous</em>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.3.2 async Functions"><div class="sect2" id="async-async-functions">
<h2>13.3.2 async Functions</h2>

<p>Because any code that uses <code>await</code> is asynchronous, there is one
critical rule: <em>you can only use the <code>await</code> keyword within functions
that have been declared with the <code>async</code> keyword</em>. Here’s a version of
the <code>getHighScore()</code> function from earlier in the chapter, rewritten
to use <code>async</code> and <code>await</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">getHighScore</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">);</code>
    <code class="kd">let</code> <code class="nx">profile</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
    <code class="k">return</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">highScore</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Declaring a function <code>async</code> means that the return value of the
function will be a Promise even if no Promise-related code appears in
the body of the function. If an <code>async</code> function appears to return
normally, then the Promise object that is the real return value of the
function will resolve to that apparent return value. And if an <code>async</code>
function appears to throw an exception, then the Promise object that
it returns will be rejected with that exception.</p>

<p>The <code>getHighScore()</code> function is declared <code>async</code>, so it returns a
Promise. And because it returns a Promise, we can use the <code>await</code>
keyword with it:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">displayHighScore</code><code class="p">(</code><code class="nx">await</code> <code class="nx">getHighScore</code><code class="p">());</code></pre>

<p>But remember, that line of code will only work if it is inside another
<code>async</code> function! You can nest <code>await</code> expressions within <code>async</code>
functions as deeply as you want. But if you’re at the top level<sup><a data-type="noteref" id="idm46198516659992-marker" href="ch13.xhtml#idm46198516659992">2</a></sup> or are inside a
function that is not <code>async</code> for some reason, then you can’t use
<code>await</code> and have to deal with a returned Promise in the regular way:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">getHighScore</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayHighScore</code><code class="p">).</code><code class="k">catch</code><code class="p">(</code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">);</code></pre>

<p>You can use the <code>async</code> keyword with any kind of function. It works
with the <code>function</code> keyword as a statement or as an expression. It
works with arrow functions and with the method shortcut form in
classes and object literals. (See <a data-type="xref" href="ch08.xhtml#functions">Chapter 8</a> for more about the
various ways to write functions.)</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.3.3 Awaiting Multiple Promises"><div class="sect2" id="async-awaiting-multiple-promises">
<h2>13.3.3 Awaiting Multiple Promises</h2>

<p>Suppose that we’ve written our <code>getJSON()</code> function using <code>async</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
    <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
    <code class="k">return</code> <code class="nx">body</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>And now suppose that we want to fetch two JSON values with this
function:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">value1</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
<code class="kd">let</code> <code class="nx">value2</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code></pre>

<p>The problem with this code is that it is unnecessarily sequential: the
fetch of the second URL will not begin until the first fetch is
complete.  If the second URL does not depend on the value obtained
from the first URL, then we should probably try to fetch the two
values at the same time. This is a case where the Promise-based nature
of <code>async</code> functions shows. In order to await a set of
concurrently executing <code>async</code> functions, we use <code>Promise.all()</code> just
as we would if working with Promises directly:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">value1</code><code class="p">,</code> <code class="nx">value2</code><code class="p">]</code> <code class="o">=</code> <code class="nx">await</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code><code class="nx">getJSON</code><code class="p">(</code><code class="nx">url1</code><code class="p">),</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url2</code><code class="p">)]);</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.3.4 Implementation Details"><div class="sect2" id="async-syntax-transform">
<h2>13.3.4 Implementation Details</h2>

<p>Finally, in order to understand how <code>async</code> functions work, it may help
to think about what is going on under the hood.</p>

<p>Suppose you write an <code>async</code> function like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* body */</code> <code class="p">}</code></pre>

<p>You can think about this as a Promise-returning function wrapped
around the body of your original function:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">resolve</code><code class="p">((</code><code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* body */</code> <code class="p">})(</code><code class="nx">x</code><code class="p">));</code>
        <code class="p">}</code>
        <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">reject</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">});</code>
<code class="p">}</code></pre>

<p>It is harder to express the <code>await</code> keyword in terms of a syntax
transformation like this one. But think of the <code>await</code> keyword
as a marker that breaks a function body up into separate, synchronous
chunks. An ES2017 interpreter can break the function body up
into a sequence of separate subfunctions, each of which gets passed
to the <code>then()</code> method of the <code>await</code>-marked Promise that precedes
it.<a data-type="indexterm" data-primary="" data-startref="ESasync13" id="idm46198516347976"/><a data-type="indexterm" data-primary="" data-startref="Kawait13" id="idm46198516347000"/><a data-type="indexterm" data-primary="" data-startref="Kasync13" id="idm46198516346056"/><a data-type="indexterm" data-primary="" data-startref="await13" id="idm46198516345112"/><a data-type="indexterm" data-primary="" data-startref="async13" id="idm46198516344168"/><a data-type="indexterm" data-primary="" data-startref="APasync13" id="idm46198516343224"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="13.4 Asynchronous Iteration"><div class="sect1" id="async-iterators">
<h1>13.4 Asynchronous Iteration</h1>

<p>We began this chapter with a discussion of callback- and event-based
asynchrony, and when we introduced Promises, we noted that they were
useful for single-shot asynchronous computations but were not
suitable for use with sources of repetitive asynchronous events, such
as <code>setInterval()</code>, the “click” event in a web browser, or the “data”
event on a Node stream. Because single Promises do not work for
sequences of asynchronous events, we also cannot use regular <code>async</code>
functions and the <code>await</code> statements for these things.</p>

<p>ES2018<a data-type="indexterm" data-primary="ES2018" data-secondary="asynchronous iterator" id="idm46198516338056"/><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="for/await loops" id="idm46198516337048"/><a data-type="indexterm" data-primary="for/await loops" id="idm46198516335864"/><a data-type="indexterm" data-primary="looping statements" data-secondary="for/await loops" id="idm46198516335192"/> provides a solution, however. Asynchronous iterators
are like the iterators described in <a data-type="xref" href="ch12.xhtml#itergene">Chapter 12</a>, but they are Promise-based and are meant to be used with a new form of the <code>for/of</code> loop:
<code>for/await</code>.</p>








<section data-type="sect2" data-pdf-bookmark="13.4.1 The for/await Loop"><div class="sect2" id="async-for-await">
<h2>13.4.1 The for/await Loop</h2>

<p>Node<a data-type="indexterm" data-primary="Node" data-secondary="asynchronous iteration in" id="idm46198516330344"/> 12 makes its readable streams asynchronously iterable. This means
you can read successive chunks of data from a stream with a
<code>for/await</code> loop like this one:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>

<code class="nx">async</code> <code class="kd">function</code> <code class="nx">parseFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">stream</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="p">{</code> <code class="nx">encoding</code><code class="o">:</code> <code class="s2">"utf-8"</code><code class="p">});</code>
    <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">chunk</code> <code class="k">of</code> <code class="nx">stream</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">parseChunk</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code> <code class="c1">// Assume parseChunk() is defined elsewhere</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Like a regular <code>await</code> expression, the <code>for/await</code> loop is
Promise-based. Roughly speaking, the asynchronous iterator produces a
Promise and the <code>for/await</code> loop waits for that Promise to fulfill,
assigns the fulfillment value to the loop variable, and runs the body
of the loop. And then it starts over, getting another Promise from the
iterator and waiting for that new Promise to fulfill.</p>

<p>Suppose you have an array of URLs:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">urls</code> <code class="o">=</code> <code class="p">[</code><code class="nx">url1</code><code class="p">,</code> <code class="nx">url2</code><code class="p">,</code> <code class="nx">url3</code><code class="p">];</code></pre>

<p>You can call <code>fetch()</code> on each URL to get an array of Promises:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">promises</code> <code class="o">=</code> <code class="nx">urls</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">url</code> <code class="o">=&gt;</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">));</code></pre>

<p>We saw earlier in the chapter that we could now use <code>Promise.all()</code> to
wait for all the Promises in the array to be fulfilled. But suppose we
want the results of the first fetch as soon as they become available
and don’t want to wait for all the URLs to be fetched. (Of course, the
first fetch might take longer than any of the others, so this is not
necessarily faster than using <code>Promise.all()</code>.) Arrays are
iterable, so we can iterate through the array of promises with a
regular <code>for/of</code> loop:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kr">const</code> <code class="nx">promise</code> <code class="k">of</code> <code class="nx">promises</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">promise</code><code class="p">;</code>
    <code class="nx">handle</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This example code uses a regular <code>for/of</code> loop with a regular
iterator. But because this iterator returns Promises, we can also use
the new <code>for/await</code> for slightly simpler code:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">response</code> <code class="k">of</code> <code class="nx">promises</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">handle</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>In this case, the <code>for/await</code> loop just builds the <code>await</code> call into
the loop and makes our code slightly more compact, but the two
examples do exactly the same thing. Importantly, both examples will
only work if they are within functions declared <code>async</code>; a <code>for/await</code>
loop is no different than a regular <code>await</code> expression in that way.</p>

<p>It is important to realize, however, that we’re using <code>for/await</code> with
a regular iterator in this example. Things are more interesting with
fully asynchronous iterators.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.4.2 Asynchronous Iterators"><div class="sect2" id="async-async-iterators">
<h2>13.4.2 Asynchronous Iterators</h2>

<p>Let’s<a data-type="indexterm" data-primary="iterators and generators" data-secondary="asynchronous" id="IAGasynch13"/><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="asynchronous iterators" id="idm46198516092472"/> review some terminology from <a data-type="xref" href="ch12.xhtml#itergene">Chapter 12</a>. An <em>iterable</em> object
is one that can be used with a <code>for/of</code> loop. It defines a method
with the symbolic name <code>Symbol.iterator</code>. This method returns an
<em>iterator</em> object. The iterator object has a <code>next()</code> method, which can
be called repeatedly to obtain the values of the iterable object. The
<code>next()</code> method of the iterator object returns <em>iteration result</em>
objects. The iteration result object has a <code>value</code> property and/or a
<code>done</code> property.</p>

<p>Asynchronous iterators are quite similar to regular iterators, but
there are two important differences. First, an asynchronously iterable
object implements a method with the symbolic name
<code>Symbol.asyncIterator</code> instead of <code>Symbol.iterator</code>. (As we saw earlier,
<code>for/await</code> is compatible with regular iterable objects but it
prefers asynchronously iterable objects, and tries the
<code>Symbol.asyncIterator</code> method before it tries the <code>Symbol.iterator</code>
method.) Second, the <code>next()</code> method of an asynchronous iterator
returns a Promise that resolves to an iterator result object instead
of returning an iterator result object directly.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In the previous section, when we used <code>for/await</code> on a regular,
synchronously iterable array of Promises, we were working with
synchronous iterator result objects in which the <code>value</code> property
was a Promise object but the <code>done</code> property was synchronous. True
asynchronous iterators return Promises for iteration result objects,
and both the <code>value</code> and the <code>done</code> properties are asynchronous. The
difference is a subtle one: with asynchronous iterators, the choice
about when iteration ends can be made asynchronously.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.4.3 Asynchronous Generators"><div class="sect2" id="async-async-generators">
<h2>13.4.3 Asynchronous Generators</h2>

<p>As<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="asynchronous generators" id="idm46198516077432"/> we saw in <a data-type="xref" href="ch12.xhtml#itergene">Chapter 12</a>, the easiest way to implement an iterator is
often to use a generator. The same is true for asynchronous iterators,
which we can implement with generator functions that we declare
<code>async</code>. An async generator has the features of async functions and
the features of generators: you can use <code>await</code> as you would in a
regular async function, and you can use <code>yield</code> as you would in a
regular generator. But values that you <code>yield</code> are automatically wrapped
in Promises. Even the syntax for async generators is a combination:
<code>async function</code> and <code>function *</code> combine into <code>async function *</code>.
Here is an example that shows how you might use an async generator and
a <code>for/await</code> loop to repetitively run code at fixed intervals using
loop syntax instead of a <code>setInterval()</code> callback function:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// A Promise-based wrapper around setTimeout() that we can use await with.</code>
<code class="c1">// Returns a Promise that fulfills in the specified number of milliseconds</code>
<code class="kd">function</code> <code class="nx">elapsedTime</code><code class="p">(</code><code class="nx">ms</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">ms</code><code class="p">));</code>
<code class="p">}</code>

<code class="c1">// An async generator function that increments a counter and yields it</code>
<code class="c1">// a specified (or infinite) number of times at a specified interval.</code>
<code class="nx">async</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">clock</code><code class="p">(</code><code class="nx">interval</code><code class="p">,</code> <code class="nx">max</code><code class="o">=</code><code class="kc">Infinity</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">count</code> <code class="o">&lt;=</code> <code class="nx">max</code><code class="p">;</code> <code class="nx">count</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// regular for loop</code>
        <code class="nx">await</code> <code class="nx">elapsedTime</code><code class="p">(</code><code class="nx">interval</code><code class="p">);</code>            <code class="c1">// wait for time to pass</code>
        <code class="k">yield</code> <code class="nx">count</code><code class="p">;</code>                            <code class="c1">// yield the counter</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// A test function that uses the async generator with for/await</code>
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">test</code><code class="p">()</code> <code class="p">{</code>                       <code class="c1">// Async so we can use for/await</code>
    <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">tick</code> <code class="k">of</code> <code class="nx">clock</code><code class="p">(</code><code class="mi">300</code><code class="p">,</code> <code class="mi">100</code><code class="p">))</code> <code class="p">{</code> <code class="c1">// Loop 100 times every 300ms</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tick</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="13.4.4 Implementing Asynchronous Iterators"><div class="sect2" id="async-async-iterator-implementation">
<h2>13.4.4 Implementing Asynchronous Iterators</h2>

<p>Instead<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="implementation" id="APasynimp13"/> of using async generators to implement asynchronous iterators,
it is also possible to implement them directly by defining an object
with a <code>Symbol.asyncIterator()</code> method that returns an object with a
<code>next()</code> method that returns a Promise that resolves to an iterator
result object. In the following code, we re-implement the <code>clock()</code>
function from the preceding example so that it is not a generator and instead just returns
an asynchronously iterable object. Notice that the <code>next()</code> method in
this example does not explicitly return a Promise; instead, we just
declare <code>next()</code> to be async:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">clock</code><code class="p">(</code><code class="nx">interval</code><code class="p">,</code> <code class="nx">max</code><code class="o">=</code><code class="kc">Infinity</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// A Promise-ified version of setTimeout that we can use await with.</code>
    <code class="c1">// Note that this takes an absolute time instead of an interval.</code>
    <code class="kd">function</code> <code class="nx">until</code><code class="p">(</code><code class="nx">time</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">time</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">()));</code>
    <code class="p">}</code>

    <code class="c1">// Return an asynchronously iterable object</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">startTime</code><code class="o">:</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">(),</code>  <code class="c1">// Remember when we started</code>
        <code class="nx">count</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>               <code class="c1">// Remember which iteration we're on</code>
        <code class="nx">async</code> <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>          <code class="c1">// The next() method makes this an iterator</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">count</code> <code class="o">&gt;</code> <code class="nx">max</code><code class="p">)</code> <code class="p">{</code>     <code class="c1">// Are we done?</code>
                <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>  <code class="c1">// Iteration result indicating done</code>
            <code class="p">}</code>
            <code class="c1">// Figure out when the next iteration should begin,</code>
            <code class="kd">let</code> <code class="nx">targetTime</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">startTime</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code> <code class="o">*</code> <code class="nx">interval</code><code class="p">;</code>
            <code class="c1">// wait until that time,</code>
            <code class="nx">await</code> <code class="nx">until</code><code class="p">(</code><code class="nx">targetTime</code><code class="p">);</code>
            <code class="c1">// and return the count value in an iteration result object.</code>
            <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="o">++</code> <code class="p">};</code>
        <code class="p">},</code>
        <code class="c1">// This method means that this iterator object is also an iterable.</code>
        <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">asyncIterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">}</code>
    <code class="p">};</code>
<code class="p">}</code></pre>

<p>This iterator-based version of the <code>clock()</code> function fixes a flaw in
the generator-based version. Note that, in this newer code, we target
the absolute time at which each iteration should begin and subtract the
current time from that in order to compute the interval that we pass
to <code>setTimeout()</code>. If we use <code>clock()</code> with a <code>for/await</code> loop, this
version will run loop iterations more precisely at the specified
interval because it accounts for the time required to actually run the
body of the loop. But this fix isn’t just about timing accuracy. The
<code>for/await</code> loop always waits for the Promise returned by one iteration to
be fulfilled before it begins the next iteration. But if you use an
asynchronous iterator without a <code>for/await</code> loop, there is nothing to
prevent you from calling the <code>next()</code> method whenever you want. With
the generator-based version of <code>clock()</code>, if you call the <code>next()</code>
method three times sequentially, you’ll get three Promises that will
all fulfill at almost exactly the same time, which is probably not
what you want. The iterator-based version we’ve implemented here does
not have that problem.</p>

<p>The benefit of asynchronous iterators is that they allow us to
represent streams of asynchronous events or data. The <code>clock()</code>
function discussed previously was fairly simple to write because the source of the
asynchrony was the <code>setTimeout()</code> calls we were making ourselves. But
when we are trying to work with other asynchronous sources, such as
the triggering of event handlers, it becomes substantially harder to
implement asynchronous iterators—we typically have a single event
handler function that responds to events, but each call to the
iterator’s <code>next()</code> method must return a distinct Promise object, and
multiple calls to <code>next()</code> may occur before the first Promise
resolves. This means that any asynchronous iterator method must be
able to maintain an internal queue of Promises that it resolves in
order as asynchronous events are occurring. If we encapsulate this Promise-queueing behavior into an AsyncQueue class, then it becomes much
easier to write asynchronous iterators based on
AsyncQueue.<sup><a data-type="noteref" id="idm46198515815416-marker" href="ch13.xhtml#idm46198515815416">3</a></sup></p>

<p>The AsyncQueue class that follows has <code>enqueue()</code> and <code>dequeue()</code> methods as
you’d expect for a queue class. The <code>dequeue()</code> method returns a
Promise rather than an actual value, however, which means that it is
OK to call <code>dequeue()</code> before <code>enqueue()</code> has ever been called. The AsyncQueue
class is also an asynchronous iterator, and is intended to be used
with a <code>for/await</code> loop whose body runs once each time a new value is
asynchronously enqueued. (AsyncQueue has a <code>close()</code> method. Once
called, no more values can be enqueued. When a closed queue is empty,
the <code>for/await</code> loop will stop looping.)</p>

<p>Note that the implementation of AsyncQueue does not use <code>async</code> or
<code>await</code> and instead works directly with Promises. The code is somewhat
complicated, and you can use it to test your understanding of the
material we’ve covered in this long chapter. Even if you don’t fully
understand the AsyncQueue implementation, do take a look at the
shorter example that follows it: it implements a simple but very
interesting asynchronous iterator on top of AsyncQueue.</p>

<pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
<code class="cm"> * An asynchronously iterable queue class. Add values with enqueue()</code>
<code class="cm"> * and remove them with dequeue(). dequeue() returns a Promise, which</code>
<code class="cm"> * means that values can be dequeued before they are enqueued. The</code>
<code class="cm"> * class implements [Symbol.asyncIterator] and next() so that it can</code>
<code class="cm"> * be used with the for/await loop (which will not terminate until</code>
<code class="cm"> * the close() method is called.)</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">AsyncQueue</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// Values that have been queued but not dequeued yet are stored here</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">values</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="c1">// When Promises are dequeued before their corresponding values are</code>
        <code class="c1">// queued, the resolve methods for those Promises are stored here.</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="c1">// Once closed, no more values can be enqueued, and no more unfulfilled</code>
        <code class="c1">// Promises returned.</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">closed</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">enqueue</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">closed</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"AsyncQueue closed"</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If this value has already been promised, resolve that Promise</code>
            <code class="kr">const</code> <code class="nx">resolve</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>
            <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// Otherwise, queue it up</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">values</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="nx">dequeue</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">values</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If there is a queued value, return a resolved Promise for it</code>
            <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">values</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>
            <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">closed</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If no queued values and we're closed, return a resolved</code>
            <code class="c1">// Promise for the "end-of-stream" marker</code>
            <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// Otherwise, return an unresolved Promise,</code>
            <code class="c1">// queuing the resolver function for later use</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">resolve</code><code class="p">);</code> <code class="p">});</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="nx">close</code><code class="p">()</code> <code class="p">{</code>
        <code class="c1">// Once the queue is closed, no more values will be enqueued.</code>
        <code class="c1">// So resolve any pending Promises with the end-of-stream marker</code>
        <code class="k">while</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">shift</code><code class="p">()(</code><code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">closed</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// Define the method that makes this class asynchronously iterable</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">asyncIterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// Define the method that makes this an asynchronous iterator. The</code>
    <code class="c1">// dequeue() Promise resolves to a value or the EOS sentinel if we're</code>
    <code class="c1">// closed. Here, we need to return a Promise that resolves to an</code>
    <code class="c1">// iterator result object.</code>
    <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">dequeue</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">value</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">value</code> <code class="o">===</code> <code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code><code class="p">)</code>
                                   <code class="o">?</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>
                                   <code class="o">:</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">});</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// A sentinel value returned by dequeue() to mark "end of stream" when closed</code>
<code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"end-of-stream"</code><code class="p">);</code></pre>

<p>Because this AsyncQueue class defines the asynchronous iteration
basics, we can create our own, more interesting asynchronous iterators
simply by asynchronously queueing values. Here’s an example that uses
AsyncQueue to produce a stream of web browser events that can be
handled<a data-type="indexterm" data-primary="" data-startref="APasynimp13" id="idm46198515797848"/><a data-type="indexterm" data-primary="" data-startref="IAGasynch13" id="idm46198515797000"/> with a <code>for/await</code> loop:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Push events of the specified type on the specified document element</code>
<code class="c1">// onto an AsyncQueue object, and return the queue for use as an event stream</code>
<code class="kd">function</code> <code class="nx">eventStream</code><code class="p">(</code><code class="nx">elt</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">q</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">AsyncQueue</code><code class="p">();</code>                  <code class="c1">// Create a queue</code>
    <code class="nx">elt</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="nx">type</code><code class="p">,</code> <code class="nx">e</code><code class="o">=&gt;</code><code class="nx">q</code><code class="p">.</code><code class="nx">enqueue</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code> <code class="c1">// Enqueue events</code>
    <code class="k">return</code> <code class="nx">q</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">async</code> <code class="kd">function</code> <code class="nx">handleKeys</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// Get a stream of keypress events and loop once for each one</code>
    <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">event</code> <code class="k">of</code> <code class="nx">eventStream</code><code class="p">(</code><code class="nb">document</code><code class="p">,</code> <code class="s2">"keypress"</code><code class="p">))</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">key</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="13.5 Summary"><div class="sect1" id="idm46198516050840">
<h1>13.5 Summary</h1>

<p>In this chapter, you have learned:</p>

<ul>
<li>
<p>Most real-world JavaScript programming is asynchronous.</p>
</li>
<li>
<p>Traditionally, asynchrony has been handled with events and callback
functions. This can get complicated, however, because you can end up
with multiple levels of callbacks nested inside other callbacks, and
because it is difficult to do robust error handling.</p>
</li>
<li>
<p>Promises provide a new way of structuring callback functions. If
used correctly (and unfortunately, Promises are easy to use
incorrectly), they can convert asynchronous code that would have
been nested into linear chains of <code>then()</code> calls where one
asynchronous step of a computation follows another. Also, Promises
allow you to centralize your error-handling code into a single
<code>catch()</code> call at the end of a chain of <code>then()</code> calls.</p>
</li>
<li>
<p>The <code>async</code> and <code>await</code> keywords allow us to write asynchronous code
that is Promise-based under the hood but that looks like
synchronous code. This makes the code easier to understand and
reason about. If a function is declared <code>async</code>, it will implicitly
return a Promise. Inside an <code>async</code> function, you can <code>await</code>
a Promise (or a function that returns a Promise) as if the Promise
value was synchronously computed.</p>
</li>
<li>
<p>Objects that are asynchronously iterable can be used with a
<code>for/await</code> loop. You can create asynchronously iterable objects by
implementing a <code>[Symbol.asyncIterator]()</code> method or by invoking an
<code>async function *</code> generator function. Asynchronous iterators
provide an alternative to “data” events on streams in Node and can
be used to represent a stream of user input events in client-side
JavaScript.</p>
</li>
</ul>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46198519434968"><sup><a href="ch13.xhtml#idm46198519434968-marker">1</a></sup> The XMLHttpRequest class has nothing in particular to do with XML. In modern client-side JavaScript, it has largely been replaced by the <code>fetch()</code> API, which is covered in <a data-type="xref" href="ch15.xhtml#fetch">§15.11.1</a>. The code example shown here is the last XMLHttpRequest-based example remaining in this book.</p><p data-type="footnote" id="idm46198516659992"><sup><a href="ch13.xhtml#idm46198516659992-marker">2</a></sup> You can typically use <code>await</code> at the top level in a browser’s developer console. And there is a pending proposal to allow top-level <code>await</code> in a future version of JavaScript.</p><p data-type="footnote" id="idm46198515815416"><sup><a href="ch13.xhtml#idm46198515815416-marker">3</a></sup> I learned about this approach to asynchronous iteration from the blog of Dr. Axel Rauschmayer, <a href="https://2ality.com"><em class="hyperlink">https://2ality.com</em></a>.</p></div></div></section></div>



  </body>
</html>