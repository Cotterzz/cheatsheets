<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style03.css" rel="stylesheet" type="text/css" />
<style type="text/css" title="ibis-book">
    @charset "utf-8";#sbo-rt-content html,#sbo-rt-content div,#sbo-rt-content div,#sbo-rt-content span,#sbo-rt-content applet,#sbo-rt-content object,#sbo-rt-content iframe,#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5,#sbo-rt-content h6,#sbo-rt-content p,#sbo-rt-content blockquote,#sbo-rt-content pre,#sbo-rt-content a,#sbo-rt-content abbr,#sbo-rt-content acronym,#sbo-rt-content address,#sbo-rt-content big,#sbo-rt-content cite,#sbo-rt-content code,#sbo-rt-content del,#sbo-rt-content dfn,#sbo-rt-content em,#sbo-rt-content img,#sbo-rt-content ins,#sbo-rt-content kbd,#sbo-rt-content q,#sbo-rt-content s,#sbo-rt-content samp,#sbo-rt-content small,#sbo-rt-content strike,#sbo-rt-content strong,#sbo-rt-content sub,#sbo-rt-content sup,#sbo-rt-content tt,#sbo-rt-content var,#sbo-rt-content b,#sbo-rt-content u,#sbo-rt-content i,#sbo-rt-content center,#sbo-rt-content dl,#sbo-rt-content dt,#sbo-rt-content dd,#sbo-rt-content ol,#sbo-rt-content ul,#sbo-rt-content li,#sbo-rt-content fieldset,#sbo-rt-content form,#sbo-rt-content label,#sbo-rt-content legend,#sbo-rt-content table,#sbo-rt-content caption,#sbo-rt-content tdiv,#sbo-rt-content tfoot,#sbo-rt-content thead,#sbo-rt-content tr,#sbo-rt-content th,#sbo-rt-content td,#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content canvas,#sbo-rt-content details,#sbo-rt-content embed,#sbo-rt-content figure,#sbo-rt-content figcaption,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content output,#sbo-rt-content ruby,#sbo-rt-content section,#sbo-rt-content summary,#sbo-rt-content time,#sbo-rt-content mark,#sbo-rt-content audio,#sbo-rt-content video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content details,#sbo-rt-content figcaption,#sbo-rt-content figure,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content section{display:block}#sbo-rt-content div{line-height:1}#sbo-rt-content ol,#sbo-rt-content ul{list-style:none}#sbo-rt-content blockquote,#sbo-rt-content q{quotes:none}#sbo-rt-content blockquote:before,#sbo-rt-content blockquote:after,#sbo-rt-content q:before,#sbo-rt-content q:after{content:none}#sbo-rt-content table{border-collapse:collapse;border-spacing:0}@page{margin:5px !important}#sbo-rt-content p{margin:10px 0 0;line-height:125%;text-align:left}#sbo-rt-content p.byline{text-align:left;margin:-33px auto 35px;font-style:italic;font-weight:bold}#sbo-rt-content div.preface p+p.byline{margin:1em 0 0 !important}#sbo-rt-content div.preface p.byline+p.byline{margin:0 !important}#sbo-rt-content div.sect1&gt;p.byline{margin:-.25em 0 1em}#sbo-rt-content div.sect1&gt;p.byline+p.byline{margin-top:-1em}#sbo-rt-content em{font-style:italic;font-family:inherit}#sbo-rt-content em strong,#sbo-rt-content strong em{font-weight:bold;font-style:italic;font-family:inherit}#sbo-rt-content strong,#sbo-rt-content span.bold{font-weight:bold}#sbo-rt-content em.replaceable{font-style:italic}#sbo-rt-content strong.userinput{font-weight:bold;font-style:normal}#sbo-rt-content span.bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content a.ulink,#sbo-rt-content a.xref,#sbo-rt-content a.email,#sbo-rt-content a.link,#sbo-rt-content a{text-decoration:none;color:#8e0012}#sbo-rt-content span.lineannotation{font-style:italic;color:#a62a2a;font-family:serif}#sbo-rt-content span.underline{text-decoration:underline}#sbo-rt-content span.strikethrough{text-decoration:line-through}#sbo-rt-content span.smallcaps{font-variant:small-caps}#sbo-rt-content span.cursor{background:#000;color:#fff}#sbo-rt-content span.smaller{font-size:75%}#sbo-rt-content .boxedtext,#sbo-rt-content .keycap{border-style:solid;border-width:1px;border-color:#000;padding:1px}#sbo-rt-content span.gray50{color:#7F7F7F;}#sbo-rt-content h1,#sbo-rt-content div.toc-title,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5{-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;font-weight:bold;text-align:left;page-break-after:avoid !important;font-family:sans-serif,"DejaVuSans"}#sbo-rt-content div.toc-title{font-size:1.5em;margin-top:20px !important;margin-bottom:30px !important}#sbo-rt-content section[data-type="sect1"] h1{font-size:1.3em;color:#8e0012;margin:40px 0 8px 0}#sbo-rt-content section[data-type="sect2"] h2{font-size:1.1em;margin:30px 0 8px 0 !important}#sbo-rt-content section[data-type="sect3"] h3{font-size:1em;color:#555;margin:20px 0 8px 0 !important}#sbo-rt-content section[data-type="sect4"] h4{font-size:1em;font-weight:normal;font-style:italic;margin:15px 0 6px 0 !important}#sbo-rt-content section[data-type="chapter"]&gt;div&gt;h1,#sbo-rt-content section[data-type="preface"]&gt;div&gt;h1,#sbo-rt-content section[data-type="appendix"]&gt;div&gt;h1,#sbo-rt-content section[data-type="glossary"]&gt;div&gt;h1,#sbo-rt-content section[data-type="bibliography"]&gt;div&gt;h1,#sbo-rt-content section[data-type="index"]&gt;div&gt;h1{font-size:2em;line-height:1;margin-bottom:50px;color:#000;padding-bottom:10px;border-bottom:1px solid #000}#sbo-rt-content span.label,#sbo-rt-content span.keep-together{font-size:inherit;font-weight:inherit}#sbo-rt-content div[data-type="part"] h1{font-size:2em;text-align:center;margin-top:0 !important;margin-bottom:50px;padding:50px 0 10px 0;border-bottom:1px solid #000}#sbo-rt-content img.width-ninety{width:90%}#sbo-rt-content img{max-width:95%;margin:0 auto;padding:0}#sbo-rt-content div.figure{background-color:transparent;text-align:center !important;margin:15px auto !important;page-break-inside:avoid}#sbo-rt-content figure{margin:15px auto !important;page-break-inside:avoid}#sbo-rt-content div.figure h6,#sbo-rt-content figure h6,#sbo-rt-content figure figcaption{font-size:.9rem !important;text-align:center;font-weight:normal !important;font-style:italic;font-family:serif !important;text-transform:none !important;letter-spacing:normal !important;color:#000;padding-top:.25em !important;margin-top:0 !important;page-break-before:avoid}#sbo-rt-content div.informalfigure{text-align:center !important;padding:5px 0 !important}#sbo-rt-content div.sidebar{margin:15px 0 10px 0 !important;border:1px solid #DCDCDC;background-color:#F7F7F7;padding:15px !important;page-break-inside:avoid}#sbo-rt-content aside[data-type="sidebar"]{margin:15px 0 10px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar-title,#sbo-rt-content aside[data-type="sidebar"] h5{font-weight:bold;font-size:1em;font-family:sans-serif;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar ol,#sbo-rt-content div.sidebar ul,#sbo-rt-content aside[data-type="sidebar"] ol,#sbo-rt-content aside[data-type="sidebar"] ul{margin-left:1.25em !important}#sbo-rt-content div.sidebar div.figure p.title,#sbo-rt-content aside[data-type="sidebar"] figcaption,#sbo-rt-content div.sidebar div.informalfigure div.caption{font-size:90%;text-align:center;font-weight:normal;font-style:italic;font-family:serif !important;color:#000;padding:5px !important;page-break-before:avoid;page-break-after:avoid}#sbo-rt-content div.sidebar div.tip,#sbo-rt-content div.sidebar div[data-type="tip"],#sbo-rt-content div.sidebar div.note,#sbo-rt-content div.sidebar div[data-type="note"],#sbo-rt-content div.sidebar div.warning,#sbo-rt-content div.sidebar div[data-type="warning"],#sbo-rt-content div.sidebar div[data-type="caution"],#sbo-rt-content div.sidebar div[data-type="important"]{margin:20px auto 20px auto !important;font-size:90%;width:85%}#sbo-rt-content aside[data-type="sidebar"] p.byline{font-size:90%;font-weight:bold;font-style:italic;text-align:center;text-indent:0;margin:5px auto 6px;page-break-after:avoid}#sbo-rt-content pre{white-space:pre-wrap;font-family:"Ubuntu Mono",monospace;margin:25px 0 25px 20px;font-size:85%;display:block;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content div.note pre.programlisting,#sbo-rt-content div.tip pre.programlisting,#sbo-rt-content div.warning pre.programlisting,#sbo-rt-content div.caution pre.programlisting,#sbo-rt-content div.important pre.programlisting{margin-bottom:0}#sbo-rt-content code{font-family:"Ubuntu Mono",monospace;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content code strong em,#sbo-rt-content code em strong,#sbo-rt-content pre em strong,#sbo-rt-content pre strong em,#sbo-rt-content strong code em code,#sbo-rt-content em code strong code,#sbo-rt-content span.bolditalic code{font-weight:bold;font-style:italic;font-family:"Ubuntu Mono BoldItal",monospace}#sbo-rt-content code em,#sbo-rt-content em code,#sbo-rt-content pre em,#sbo-rt-content em.replaceable{font-family:"Ubuntu Mono Ital",monospace;font-style:italic}#sbo-rt-content code strong,#sbo-rt-content strong code,#sbo-rt-content pre strong,#sbo-rt-content strong.userinput{font-family:"Ubuntu Mono Bold",monospace;font-weight:bold}#sbo-rt-content div[data-type="example"]{margin:10px 0 15px 0 !important}#sbo-rt-content div[data-type="example"] h1,#sbo-rt-content div[data-type="example"] h2,#sbo-rt-content div[data-type="example"] h3,#sbo-rt-content div[data-type="example"] h4,#sbo-rt-content div[data-type="example"] h5,#sbo-rt-content div[data-type="example"] h6{font-style:italic;font-weight:normal;text-align:left !important;text-transform:none !important;font-family:serif !important;margin:10px 0 5px 0 !important;border-bottom:1px solid #000}#sbo-rt-content li pre.example{padding:10px 0 !important}#sbo-rt-content div[data-type="example"] pre[data-type="programlisting"],#sbo-rt-content div[data-type="example"] pre[data-type="screen"]{margin:0}#sbo-rt-content section[data-type="titlepage"]&gt;div&gt;h1{font-size:2em;margin:50px 0 10px 0 !important;line-height:1;text-align:center}#sbo-rt-content section[data-type="titlepage"] h2,#sbo-rt-content section[data-type="titlepage"] p.subtitle,#sbo-rt-content section[data-type="titlepage"] p[data-type="subtitle"]{font-size:1.3em;font-weight:normal;text-align:center;margin-top:.5em;color:#555}#sbo-rt-content section[data-type="titlepage"]&gt;div&gt;h2[data-type="author"],#sbo-rt-content section[data-type="titlepage"] p.author{font-size:1.3em;font-family:serif !important;font-weight:bold;margin:50px 0 !important;text-align:center}#sbo-rt-content section[data-type="titlepage"] p.edition{text-align:center;text-transform:uppercase;margin-top:2em}#sbo-rt-content section[data-type="titlepage"]{text-align:center}#sbo-rt-content section[data-type="titlepage"]:after{content:url(css_assets/titlepage_footer_ebook.png);margin:0 auto;max-width:80%}#sbo-rt-content div.book div.titlepage div.publishername{margin-top:60%;margin-bottom:20px;text-align:center;font-size:1.25em}#sbo-rt-content div.book div.titlepage div.locations p{margin:0;text-align:center}#sbo-rt-content div.book div.titlepage div.locations p.cities{font-size:80%;text-align:center;margin-top:5px}#sbo-rt-content section.preface[title="Dedication"]&gt;div.titlepage h2.title{text-align:center;text-transform:uppercase;font-size:1.5em;margin-top:50px;margin-bottom:50px}#sbo-rt-content ul.stafflist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.stafflist li{list-style-type:none;padding:5px 0}#sbo-rt-content ul.printings li{list-style-type:none}#sbo-rt-content section.preface[title="Dedication"] p{font-style:italic;text-align:center}#sbo-rt-content div.colophon h1.title{font-size:1.3em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon h2.subtitle{margin:0 !important;color:#000;font-family:serif !important;font-size:1em;font-weight:normal}#sbo-rt-content div.colophon div.author h3.author{font-size:1.1em;font-family:serif !important;margin:10px 0 0 !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h4,#sbo-rt-content div.colophon div.editor h3.editor{color:#000;font-size:.8em;margin:15px 0 0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h3.editor{font-size:.8em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.publisher{margin-top:10px}#sbo-rt-content div.colophon div.publisher p,#sbo-rt-content div.colophon div.publisher span.publishername{margin:0;font-size:.8em}#sbo-rt-content div.legalnotice p,#sbo-rt-content div.timestamp p{font-size:.8em}#sbo-rt-content div.timestamp p{margin-top:10px}#sbo-rt-content div.colophon[title="About the Author"] h1.title,#sbo-rt-content div.colophon[title="Colophon"] h1.title{font-size:1.5em;margin:0 !important;font-family:sans-serif !important}#sbo-rt-content section.chapter div.titlepage div.author{margin:10px 0 10px 0}#sbo-rt-content section.chapter div.titlepage div.author div.affiliation{font-style:italic}#sbo-rt-content div.attribution{margin:5px 0 0 50px !important}#sbo-rt-content h3.author span.orgname{display:none}#sbo-rt-content div.epigraph{margin:10px 0 10px 20px !important;page-break-inside:avoid;font-size:90%}#sbo-rt-content div.epigraph p{font-style:italic}#sbo-rt-content blockquote,#sbo-rt-content div.blockquote{margin:10px !important;page-break-inside:avoid;font-size:95%}#sbo-rt-content blockquote p,#sbo-rt-content div.blockquote p{font-style:italic;margin:.75em 0 0 !important}#sbo-rt-content blockquote div.attribution,#sbo-rt-content blockquote p[data-type="attribution"]{margin:5px 0 10px 30px !important;text-align:right;width:80%}#sbo-rt-content blockquote div.attribution p,#sbo-rt-content blockquote p[data-type="attribution"]{font-style:normal;margin-top:5px}#sbo-rt-content blockquote div.attribution p:before,#sbo-rt-content blockquote p[data-type="attribution"]:before{font-style:normal;content:"—";-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none}#sbo-rt-content p.right{text-align:right;margin:0}#sbo-rt-content div[data-type="footnotes"]{border-top:1px solid black;margin-top:2em}#sbo-rt-content sub,#sbo-rt-content sup{font-size:75%;line-height:0;position:relative}#sbo-rt-content sup{top:-.5em}#sbo-rt-content sub{bottom:-.25em}#sbo-rt-content p[data-type="footnote"]{font-size:90% !important;line-height:1.2em !important;margin-left:2.5em !important;text-indent:-2.3em !important}#sbo-rt-content p[data-type="footnote"] sup{display:inline-block !important;position:static !important;width:2em !important;text-align:right !important;font-size:100% !important;padding-right:.5em !important}#sbo-rt-content p[data-type="footnote"] a[href$="-marker"]{font-family:sans-serif !important;font-size:90% !important;color:#8e0012 !important}#sbo-rt-content p[data-type="footnote"] a[data-type="xref"]{margin:0 !important;padding:0 !important;text-indent:0 !important}#sbo-rt-content a[data-type="noteref"]{font-family:sans-serif !important;color:#8e0012;margin-left:0;padding-left:0}#sbo-rt-content div.refentry p.refname{font-size:1em;font-family:sans-serif,"DejaVuSans";font-weight:bold;margin-bottom:5px;overflow:auto;width:100%}#sbo-rt-content div.refentry{width:100%;display:block;margin-top:2em}#sbo-rt-content div.refsynopsisdiv{display:block;clear:both}#sbo-rt-content div.refentry header{page-break-inside:avoid !important;display:block;break-inside:avoid !important;padding-top:0;border-bottom:1px solid #000}#sbo-rt-content div.refsect1 h6{font-size:.9em;font-family:sans-serif,"DejaVuSans";font-weight:bold}#sbo-rt-content div.refsect1{margin-top:3em}#sbo-rt-content dl{margin-bottom:1.5em !important}#sbo-rt-content dt{padding-top:10px !important;padding-bottom:0 !important;line-height:1.25rem;font-style:italic}#sbo-rt-content dd{margin:10px 0 .25em 1.5em !important;line-height:1.65em !important}#sbo-rt-content dd p{padding:0 !important;margin:0 0 10px !important}#sbo-rt-content dd ol,#sbo-rt-content dd ul{padding-left:1em}#sbo-rt-content dd li{margin-top:0;margin-bottom:0}#sbo-rt-content dd,#sbo-rt-content li{text-align:left}#sbo-rt-content ul,#sbo-rt-content ul&gt;li,#sbo-rt-content ol ul,#sbo-rt-content ol ul&gt;li,#sbo-rt-content ul ol ul,#sbo-rt-content ul ol ul&gt;li{list-style-type:disc}#sbo-rt-content ul ul,#sbo-rt-content ul ul&gt;li{list-style-type:square}#sbo-rt-content ul ul ul,#sbo-rt-content ul ul ul&gt;li{list-style-type:circle}#sbo-rt-content ol,#sbo-rt-content ol&gt;li,#sbo-rt-content ol ul ol,#sbo-rt-content ol ul ol&gt;li,#sbo-rt-content ul ol,#sbo-rt-content ul ol&gt;li{list-style-type:decimal}#sbo-rt-content ol ol,#sbo-rt-content ol ol&gt;li{list-style-type:lower-alpha}#sbo-rt-content ol ol ol,#sbo-rt-content ol ol ol&gt;li{list-style-type:lower-roman}#sbo-rt-content ol,#sbo-rt-content ul{list-style-position:outside;margin:15px 0 15px 1.25em;padding-left:2.25em}#sbo-rt-content ol li,#sbo-rt-content ul li{margin:.5em 0 .65em;line-height:125%}#sbo-rt-content div.orderedlistalpha{list-style-type:upper-alpha}#sbo-rt-content table.simplelist,#sbo-rt-content ul.simplelist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.simplelist li{list-style-type:none;padding:5px 0}#sbo-rt-content table.simplelist td{border:none}#sbo-rt-content table.simplelist tr{border-bottom:none}#sbo-rt-content table.simplelist tr:nth-of-type(even){background-color:transparent}#sbo-rt-content dl.calloutlist p:first-child{margin-top:-25px !important}#sbo-rt-content dl.calloutlist dd{padding-left:0;margin-top:-25px}#sbo-rt-content dl.calloutlist img,#sbo-rt-content a.co img{padding:0}#sbo-rt-content div.toc ol{margin-top:8px !important;margin-bottom:8px !important;margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.toc ol ol{margin-left:30px !important;padding-left:0 !important}#sbo-rt-content div.toc ol li{list-style-type:none}#sbo-rt-content div.toc a{color:#8e0012}#sbo-rt-content div.toc ol a{font-size:1em;font-weight:bold}#sbo-rt-content div.toc ol&gt;li&gt;ol a{font-weight:bold;font-size:1em}#sbo-rt-content div.toc ol&gt;li&gt;ol&gt;li&gt;ol a{text-decoration:none;font-weight:normal;font-size:1em}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"],#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{margin:30px !important;font-size:90%;padding:10px 8px 20px 8px !important;page-break-inside:avoid}#sbo-rt-content div.tip ol,#sbo-rt-content div.tip ul,#sbo-rt-content div[data-type="tip"] ol,#sbo-rt-content div[data-type="tip"] ul,#sbo-rt-content div.note ol,#sbo-rt-content div.note ul,#sbo-rt-content div[data-type="note"] ol,#sbo-rt-content div[data-type="note"] ul,#sbo-rt-content div.warning ol,#sbo-rt-content div.warning ul,#sbo-rt-content div[data-type="warning"] ol,#sbo-rt-content div[data-type="warning"] ul,#sbo-rt-content div[data-type="caution"] ol,#sbo-rt-content div[data-type="caution"] ul,#sbo-rt-content div[data-type="important"] ol,#sbo-rt-content div[data-type="important"] ul{margin-left:1.5em !important}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"]{border:1px solid #BEBEBE;background-color:transparent}#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{border:1px solid #BC8F8F}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="note"] h1,#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1,#sbo-rt-content div[data-type="important"] h6{font-weight:bold;font-size:110%;font-family:sans-serif !important;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px !important}#sbo-rt-content div[data-type="tip"] figure h6,#sbo-rt-content div[data-type="note"] figure h6,#sbo-rt-content div[data-type="warning"] figure h6,#sbo-rt-content div[data-type="caution"] figure h6,#sbo-rt-content div[data-type="important"] figure h6{font-family:serif !important}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div[data-type="note"] h1{color:#737373}#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="important"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1{color:#C67171}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note,#sbo-rt-content div.safarienabled{background-color:transparent;margin:8px 0 0 !important;border:0 solid #BEBEBE;font-size:100%;padding:0 !important;page-break-inside:avoid}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note h3,#sbo-rt-content div.safarienabled h6{display:none}#sbo-rt-content div.table,#sbo-rt-content table{margin:15px 0 30px 0 !important;max-width:95%;border:none !important;background:none;display:table !important}#sbo-rt-content div.table,#sbo-rt-content div.informaltable,#sbo-rt-content table{page-break-inside:avoid}#sbo-rt-content table li{margin:10px 0 0 .25em !important}#sbo-rt-content tr,#sbo-rt-content tr td{border-bottom:1px solid #c3c3c3}#sbo-rt-content thead td,#sbo-rt-content thead th{border-bottom:#9d9d9d 1px solid !important;border-top:#9d9d9d 1px solid !important}#sbo-rt-content tr:nth-of-type(even){background-color:#f1f6fc}#sbo-rt-content thead{font-family:sans-serif;font-weight:bold}#sbo-rt-content td,#sbo-rt-content th{display:table-cell;padding:.3em;text-align:left;vertical-align:top;font-size:80%}#sbo-rt-content th{vertical-align:bottom}#sbo-rt-content div.informaltable table{margin:10px auto !important}#sbo-rt-content div.informaltable table tr{border-bottom:none}#sbo-rt-content div.informaltable table tr:nth-of-type(even){background-color:transparent}#sbo-rt-content div.informaltable td,#sbo-rt-content div.informaltable th{border:#9d9d9d 1px solid}#sbo-rt-content div.table-title,#sbo-rt-content table caption{font-weight:normal;font-style:italic;font-family:serif;font-size:1em;margin:10px 0 10px 0 !important;padding:0;page-break-after:avoid;text-align:left !important}#sbo-rt-content table code{font-size:smaller;word-break:break-all}#sbo-rt-content table.border tbody&gt;tr:last-child&gt;td{border-bottom:transparent}#sbo-rt-content div.equation,#sbo-rt-content div[data-type="equation"]{margin:10px 0 15px 0 !important}#sbo-rt-content div.equation-title,#sbo-rt-content div[data-type="equation"] h5{font-style:italic;font-weight:normal;font-family:serif !important;font-size:90%;margin:20px 0 10px 0 !important;page-break-after:avoid}#sbo-rt-content div.equation-contents{margin-left:20px}#sbo-rt-content div[data-type="equation"] math{font-size:calc(.35em + 1vw)}#sbo-rt-content span.inlinemediaobject{height:.85em;display:inline-block;margin-bottom:.2em}#sbo-rt-content span.inlinemediaobject img{margin:0;height:.85em}#sbo-rt-content div.informalequation{margin:20px 0 20px 20px;width:75%}#sbo-rt-content div.informalequation img{width:75%}#sbo-rt-content div.index{text-indent:0}#sbo-rt-content div.index h3{padding:.25em;margin-top:1em !important;background-color:#F0F0F0}#sbo-rt-content div.index li{line-height:130%;list-style-type:none}#sbo-rt-content div.index a.indexterm{color:#8e0012 !important}#sbo-rt-content div.index ul{margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.index ul ul{margin-left:2em !important;margin-top:0 !important}#sbo-rt-content code.boolean,#sbo-rt-content .navy{color:rgb(0,0,128);}#sbo-rt-content code.character,#sbo-rt-content .olive{color:rgb(128,128,0);}#sbo-rt-content code.comment,#sbo-rt-content .blue{color:rgb(0,0,255);}#sbo-rt-content code.conditional,#sbo-rt-content .limegreen{color:rgb(50,205,50);}#sbo-rt-content code.constant,#sbo-rt-content .darkorange{color:rgb(255,140,0);}#sbo-rt-content code.debug,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.define,#sbo-rt-content .darkgoldenrod,#sbo-rt-content .gold{color:rgb(184,134,11);}#sbo-rt-content code.delimiter,#sbo-rt-content .dimgray{color:rgb(105,105,105);}#sbo-rt-content code.error,#sbo-rt-content .red{color:rgb(255,0,0);}#sbo-rt-content code.exception,#sbo-rt-content .salmon{color:rgb(250,128,11);}#sbo-rt-content code.float,#sbo-rt-content .steelblue{color:rgb(70,130,180);}#sbo-rt-content pre code.function,#sbo-rt-content .green{color:rgb(0,128,0);}#sbo-rt-content code.identifier,#sbo-rt-content .royalblue{color:rgb(65,105,225);}#sbo-rt-content code.ignore,#sbo-rt-content .gray{color:rgb(128,128,128);}#sbo-rt-content code.include,#sbo-rt-content .purple{color:rgb(128,0,128);}#sbo-rt-content code.keyword,#sbo-rt-content .sienna{color:rgb(160,82,45);}#sbo-rt-content code.label,#sbo-rt-content .deeppink{color:rgb(255,20,147);}#sbo-rt-content code.macro,#sbo-rt-content .orangered{color:rgb(255,69,0);}#sbo-rt-content code.number,#sbo-rt-content .brown{color:rgb(165,42,42);}#sbo-rt-content code.operator,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.preCondit,#sbo-rt-content .teal{color:rgb(0,128,128);}#sbo-rt-content code.preProc,#sbo-rt-content .fuschia{color:rgb(255,0,255);}#sbo-rt-content code.repeat,#sbo-rt-content .indigo{color:rgb(75,0,130);}#sbo-rt-content code.special,#sbo-rt-content .saddlebrown{color:rgb(139,69,19);}#sbo-rt-content code.specialchar,#sbo-rt-content .magenta{color:rgb(255,0,255);}#sbo-rt-content code.specialcomment,#sbo-rt-content .seagreen{color:rgb(46,139,87);}#sbo-rt-content code.statement,#sbo-rt-content .forestgreen{color:rgb(34,139,34);}#sbo-rt-content code.storageclass,#sbo-rt-content .plum{color:rgb(221,160,221);}#sbo-rt-content code.string,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.structure,#sbo-rt-content .chocolate{color:rgb(210,106,30);}#sbo-rt-content code.tag,#sbo-rt-content .darkcyan{color:rgb(0,139,139);}#sbo-rt-content code.todo,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.type,#sbo-rt-content .mediumslateblue{color:rgb(123,104,238);}#sbo-rt-content code.typedef,#sbo-rt-content .darkgreen{color:rgb(0,100,0);}#sbo-rt-content code.underlined{text-decoration:underline;}#sbo-rt-content pre code.hll{background-color:#ffc}#sbo-rt-content pre code.c{color:#09F;font-style:italic}#sbo-rt-content pre code.err{color:#A00}#sbo-rt-content pre code.k{color:#069;font-weight:bold}#sbo-rt-content pre code.o{color:#555}#sbo-rt-content pre code.cm{color:#35586C;font-style:italic}#sbo-rt-content pre code.cp{color:#099}#sbo-rt-content pre code.c1{color:#35586C;font-style:italic}#sbo-rt-content pre code.cs{color:#35586C;font-weight:bold;font-style:italic}#sbo-rt-content pre code.gd{background-color:#FCC}#sbo-rt-content pre code.ge{font-style:italic}#sbo-rt-content pre code.gr{color:#F00}#sbo-rt-content pre code.gh{color:#030;font-weight:bold}#sbo-rt-content pre code.gi{background-color:#CFC}#sbo-rt-content pre code.go{color:#000}#sbo-rt-content pre code.gp{color:#009;font-weight:bold}#sbo-rt-content pre code.gs{font-weight:bold}#sbo-rt-content pre code.gu{color:#030;font-weight:bold}#sbo-rt-content pre code.gt{color:#9C6}#sbo-rt-content pre code.kc{color:#069;font-weight:bold}#sbo-rt-content pre code.kd{color:#069;font-weight:bold}#sbo-rt-content pre code.kn{color:#069;font-weight:bold}#sbo-rt-content pre code.kp{color:#069}#sbo-rt-content pre code.kr{color:#069;font-weight:bold}#sbo-rt-content pre code.kt{color:#078;font-weight:bold}#sbo-rt-content pre code.m{color:#F60}#sbo-rt-content pre code.s{color:#C30}#sbo-rt-content pre code.na{color:#309}#sbo-rt-content pre code.nb{color:#366}#sbo-rt-content pre code.nc{color:#0A8;font-weight:bold}#sbo-rt-content pre code.no{color:#360}#sbo-rt-content pre code.nd{color:#99F}#sbo-rt-content pre code.ni{color:#999;font-weight:bold}#sbo-rt-content pre code.ne{color:#C00;font-weight:bold}#sbo-rt-content pre code.nf{color:#C0F}#sbo-rt-content pre code.nl{color:#99F}#sbo-rt-content pre code.nn{color:#0CF;font-weight:bold}#sbo-rt-content pre code.nt{color:#309;font-weight:bold}#sbo-rt-content pre code.nv{color:#033}#sbo-rt-content pre code.ow{color:#000;font-weight:bold}#sbo-rt-content pre code.w{color:#bbb}#sbo-rt-content pre code.mf{color:#F60}#sbo-rt-content pre code.mh{color:#F60}#sbo-rt-content pre code.mi{color:#F60}#sbo-rt-content pre code.mo{color:#F60}#sbo-rt-content pre code.sb{color:#C30}#sbo-rt-content pre code.sc{color:#C30}#sbo-rt-content pre code.sd{color:#C30;font-style:italic}#sbo-rt-content pre code.s2{color:#C30}#sbo-rt-content pre code.se{color:#C30;font-weight:bold}#sbo-rt-content pre code.sh{color:#C30}#sbo-rt-content pre code.si{color:#A00}#sbo-rt-content pre code.sx{color:#C30}#sbo-rt-content pre code.sr{color:#3AA}#sbo-rt-content pre code.s1{color:#C30}#sbo-rt-content pre code.ss{color:#A60}#sbo-rt-content pre code.bp{color:#366}#sbo-rt-content pre code.vc{color:#033}#sbo-rt-content pre code.vg{color:#033}#sbo-rt-content pre code.vi{color:#033}#sbo-rt-content pre code.il{color:#F60}#sbo-rt-content pre code.g{color:#050}#sbo-rt-content pre code.l{color:#C60}#sbo-rt-content pre code.l{color:#F90}#sbo-rt-content pre code.n{color:#008}#sbo-rt-content pre code.nx{color:#008}#sbo-rt-content pre code.py{color:#96F}#sbo-rt-content pre code.p{color:#000}#sbo-rt-content pre code.x{color:#F06}#sbo-rt-content div.blockquote_sampler_toc{width:95%;margin:5px 5px 5px 10px !important}#sbo-rt-content div{font-family:serif;text-align:left}#sbo-rt-content .gray-background,#sbo-rt-content .reverse-video{background:#2E2E2E;color:#FFF}#sbo-rt-content .light-gray-background{background:#A0A0A0}#sbo-rt-content .preserve-whitespace{white-space:pre-wrap}#sbo-rt-content pre.break-code,#sbo-rt-content code.break-code,#sbo-rt-content .break-code pre,#sbo-rt-content .break-code code{word-break:break-all}#sbo-rt-content span.gray{color:#4C4C4C}#sbo-rt-content .width-10,#sbo-rt-content figure.width-10 img{width:10% !important}#sbo-rt-content .width-20,#sbo-rt-content figure.width-20 img{width:20% !important}#sbo-rt-content .width-30,#sbo-rt-content figure.width-30 img{width:30% !important}#sbo-rt-content .width-40,#sbo-rt-content figure.width-40 img{width:40% !important}#sbo-rt-content .width-50,#sbo-rt-content figure.width-50 img{width:50% !important}#sbo-rt-content .width-60,#sbo-rt-content figure.width-60 img{width:60% !important}#sbo-rt-content .width-70,#sbo-rt-content figure.width-70 img{width:70% !important}#sbo-rt-content .width-80,#sbo-rt-content figure.width-80 img{width:80% !important}#sbo-rt-content .width-90,#sbo-rt-content figure.width-90 img{width:90% !important}#sbo-rt-content .width-full,#sbo-rt-content .width-100{width:100% !important}#sbo-rt-content .sc{text-transform:none !important}#sbo-rt-content .right{float:none !important}#sbo-rt-content a.totri-footnote{padding:0 !important}#sbo-rt-content figure.width-10,#sbo-rt-content figure.width-20,#sbo-rt-content figure.width-30,#sbo-rt-content figure.width-40,#sbo-rt-content figure.width-50,#sbo-rt-content figure.width-60,#sbo-rt-content figure.width-70,#sbo-rt-content figure.width-80,#sbo-rt-content figure.width-90{width:auto !important}#sbo-rt-content p img,#sbo-rt-content pre img{height:1em;width:1em}#sbo-rt-content .tablerule td{border-bottom:.25pt solid black !important}
    </style>
<style type="text/css" id="font-styles">#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: &lt;%= font_size %&gt; !important; }</style>
<style type="text/css" id="font-family">#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: &lt;%= font_family %&gt; !important; }</style>
<style type="text/css" id="column-width">#sbo-rt-content { max-width: &lt;%= column_width %&gt;% !important; margin: 0 auto !important; }</style>

<style type="text/css">body{margin:1em;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}body{background-color:transparent!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Classes"><div class="chapter" id="classes">
<h1><span class="label">Chapter 9. </span>Classes</h1>


<p>JavaScript<a data-type="indexterm" data-primary="classes" data-secondary="overview of" id="idm46198536023816"/> objects were covered in <a data-type="xref" href="ch06.xhtml#objects">Chapter 6</a>. That chapter treated
each object as a unique set of properties, different from every other
object. It is often useful, however, to define a <em>class</em> of objects
that share certain properties. Members, or <em>instances</em>, of the class
have their own properties to hold or define their state, but they also
have methods that define their behavior. These methods are defined by
the class and shared by all instances. Imagine a class named Complex
that represents and performs arithmetic on complex numbers, for
example. A Complex instance would have properties to hold the real and
imaginary parts (the state) of the complex number. And the Complex
class would define methods to perform addition and multiplication (the
behavior) of those numbers.</p>

<p>In JavaScript, classes use prototype-based inheritance: if two objects
inherit properties (generally function-valued properties, or methods)
from the same prototype, then we say that those objects are instances
of the same class. That, in a nutshell, is how JavaScript classes
work.  JavaScript prototypes and inheritance were covered in
<a data-type="xref" href="ch06.xhtml#prototypes">§6.2.3</a> and <a data-type="xref" href="ch06.xhtml#inheritance">§6.3.2</a>, and you will need to be familiar
with the material in those sections to understand this chapter. This
chapter covers prototypes in <a data-type="xref" href="#classesandprototypes">§9.1</a>.</p>

<p>If two objects inherit from the same prototype, this typically (but
not necessarily) means that they were created and initialized by the
same constructor function or factory function. Constructors have been
covered in <a data-type="xref" href="ch04.xhtml#newexprs">§4.6</a>, <a data-type="xref" href="ch06.xhtml#creatingobjectswithnew">§6.2.2</a>, and
<a data-type="xref" href="ch08.xhtml#constructorinvocation">§8.2.3</a>, and this chapter has more in
<a data-type="xref" href="#classesandconstructors">§9.2</a>.</p>

<p>JavaScript has always allowed the definition of classes. ES6
introduced a brand-new syntax (including a <code>class</code> keyword) that makes
it even easier to create classes. These new JavaScript classes work
in the same way that old-style classes do, and this chapter starts by
explaining the old way of creating classes because that demonstrates
more clearly what is going on behind the scenes to make classes
work. Once we’ve explained those fundamentals, we’ll shift and start
using the new, simplified class definition syntax.</p>

<p>If you’re familiar with strongly typed object-oriented programming
languages like Java or C++, you’ll notice that JavaScript classes are
quite different from classes in those languages. There are some
syntactic similarities, and you can emulate many features of
“classical” classes in JavaScript, but it is best to understand up
front that <span class="keep-together">JavaScript’s</span> classes and prototype-based inheritance
mechanism are substantially different from the classes and class-based
inheritance mechanism of Java and similar languages.</p>






<section data-type="sect1" data-pdf-bookmark="9.1 Classes and Prototypes"><div class="sect1" id="classesandprototypes">
<h1>9.1 Classes and Prototypes</h1>

<p>In<a data-type="indexterm" data-primary="classes" data-secondary="classes and prototypes" id="idm46198536007816"/><a data-type="indexterm" data-primary="prototypes" id="idm46198536006808"/> JavaScript, a class is a set of objects that inherit properties
from the same prototype object. The prototype object, therefore, is
the central feature of a class. <a data-type="xref" href="ch06.xhtml#objects">Chapter 6</a> covered the
<code>Object.create()</code> function that returns a newly created object that
inherits from a specified prototype object. If we define a prototype
object and then use <code>Object.create()</code> to create objects that inherit
from it, we have defined a JavaScript class. Usually, the instances of
a class require further initialization, and it is common to define a
function that creates and initializes the new object. <a data-type="xref" href="#range1.js">Example 9-1</a>
demonstrates this: it defines a prototype object for a class that
represents a range of values and also<a data-type="indexterm" data-primary="factory functions" id="idm46198536002840"/><a data-type="indexterm" data-primary="functions" data-secondary="factory functions" id="idm46198536002168"/> defines a <em>factory
function</em> that creates and initializes a new instance of the class.</p>
<div id="range1.js" data-type="example">
<h5><span class="label">Example 9-1. </span>A simple JavaScript class</h5>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// This is a factory function that returns a new range object.</code>
<code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Use Object.create() to create an object that inherits from the</code>
    <code class="c1">// prototype object defined below.  The prototype object is stored as</code>
    <code class="c1">// a property of this function, and defines the shared methods (behavior)</code>
    <code class="c1">// for all range objects.</code>
    <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">range</code><code class="p">.</code><code class="nx">methods</code><code class="p">);</code>

    <code class="c1">// Store the start and end points (state) of this new range object.</code>
    <code class="c1">// These are noninherited properties that are unique to this object.</code>
    <code class="nx">r</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
    <code class="nx">r</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>

    <code class="c1">// Finally return the new object</code>
    <code class="k">return</code> <code class="nx">r</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// This prototype object defines methods inherited by all range objects.</code>
<code class="nx">range</code><code class="p">.</code><code class="nx">methods</code> <code class="o">=</code> <code class="p">{</code>
    <code class="c1">// Return true if x is in the range, false otherwise</code>
    <code class="c1">// This method works for textual and Date ranges as well as numeric.</code>
    <code class="nx">includes</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">},</code>

    <code class="c1">// A generator function that makes instances of the class iterable.</code>
    <code class="c1">// Note that it only works for numeric ranges.</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="c1">// Return a string representation of the range</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"("</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">+</code> <code class="s2">"..."</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">+</code> <code class="s2">")"</code><code class="p">;</code> <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// Here are example uses of a range object.</code>
<code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="nx">range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>      <code class="c1">// Create a range object</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>            <code class="c1">// =&gt; true: 2 is in the range</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>             <code class="c1">// =&gt; "(1...3)"</code>
<code class="p">[...</code><code class="nx">r</code><code class="p">]</code>                   <code class="c1">// =&gt; [1, 2, 3]; convert to an array via iterator</code></pre></div>

<p>There are a few things worth noting in the code of <a data-type="xref" href="#range1.js">Example 9-1</a>:</p>

<ul>
<li>
<p>This code defines a factory function <code>range()</code> for creating new
Range objects.</p>
</li>
<li>
<p>It uses the <code>methods</code> property of this <code>range()</code> function as a
convenient place to store the prototype object that defines the
class. There is nothing special or idiomatic about putting the
prototype object here.</p>
</li>
<li>
<p>The <code>range()</code> function defines <code>from</code> and <code>to</code> properties on each
Range object. These are the unshared, noninherited properties that
define the unique state of each individual Range object.</p>
</li>
<li>
<p>The <code>range.methods</code> object uses the ES6 shorthand syntax for
defining methods, which is why you don’t see the <code>function</code> keyword
anywhere. (See <a data-type="xref" href="ch06.xhtml#object-literal-shorthand-methods">§6.10.5</a> to
review object literal shorthand method syntax.)</p>
</li>
<li>
<p>One of the methods in the prototype has the computed name
(<a data-type="xref" href="ch06.xhtml#computed-property-names">§6.10.2</a>) <code>Symbol.iterator</code>, which means that it
is defining an iterator for Range objects. The name of this method
is prefixed with <code>*</code>, which indicates that it is a generator function
instead of a regular function. Iterators and generators are covered
in detail in <a data-type="xref" href="ch12.xhtml#itergene">Chapter 12</a>. For now, the upshot is that instances of
this Range class can be used with the <code>for/of</code> loop and with the
<code>...</code> spread operator.</p>
</li>
<li>
<p>The shared, inherited methods defined in <code>range.methods</code> all use the
<code>from</code> and <code>to</code> properties that were initialized in the <code>range()</code>
factory function. In order to refer to them, they use the <code>this</code>
keyword to refer to the object through which they were invoked. This
use of <code>this</code> is a fundamental characteristic of the methods of any
class.</p>
</li>
</ul>
</div></section>













<section data-type="sect1" data-pdf-bookmark="9.2 Classes and Constructors"><div class="sect1" id="classesandconstructors">
<h1>9.2 Classes and Constructors</h1>

<p><a data-type="xref" href="#range1.js">Example 9-1</a> demonstrates<a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" id="Cconst09"/><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" id="Cclass09"/> a simple way to define a JavaScript
class. It is not the idiomatic way to do so, however, because it did
not define a <em>constructor</em>. A constructor is a function designed for
the initialization of newly created objects. Constructors are invoked
using the <code>new</code> keyword as described in
<a data-type="xref" href="ch08.xhtml#constructorinvocation">§8.2.3</a>. Constructor invocations using <code>new</code>
automatically create the new object, so the constructor itself only
needs to initialize the state of that new object. The critical feature
of constructor invocations is that the <code>prototype</code> property of the
constructor is used as the prototype of the new object. <a data-type="xref" href="ch06.xhtml#prototypes">§6.2.3</a> introduced prototypes and emphasized that while almost all objects have a prototype, only a few objects have a <code>prototype</code> property. Finally, we can clarify this: it is function objects that have a <code>prototype</code> property. This means
that all objects created with the same constructor function inherit from the
same object and are therefore members of the same class.
<a data-type="xref" href="#range2.js">Example 9-2</a> shows how we could alter the Range class of
<a data-type="xref" href="#range1.js">Example 9-1</a> to use a constructor function instead of a factory
function. <a data-type="xref" href="#range2.js">Example 9-2</a> demonstrates the idiomatic way to create a
class in versions of JavaScript that do not support the ES6 <code>class</code>
keyword. Even though <code>class</code> is well supported now, there is still
lots of older JavaScript code around that defines classes like this,
and you should be familiar with the idiom so that you can read old
code and so that you understand what is going on “under the hood”
when you use the <code>class</code> keyword.</p>
<div id="range2.js" data-type="example">
<h5><span class="label">Example 9-2. </span>A Range class using a constructor</h5>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// This is a constructor function that initializes new Range objects.</code>
<code class="c1">// Note that it does not create or return the object. It just initializes this.</code>
<code class="kd">function</code> <code class="nx">Range</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Store the start and end points (state) of this new range object.</code>
    <code class="c1">// These are noninherited properties that are unique to this object.</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// All Range objects inherit from this object.</code>
<code class="c1">// Note that the property name must be "prototype" for this to work.</code>
<code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="p">{</code>
    <code class="c1">// Return true if x is in the range, false otherwise</code>
    <code class="c1">// This method works for textual and Date ranges as well as numeric.</code>
    <code class="nx">includes</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">},</code>

    <code class="c1">// A generator function that makes instances of the class iterable.</code>
    <code class="c1">// Note that it only works for numeric ranges.</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="o">*</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
    <code class="p">},</code>

    <code class="c1">// Return a string representation of the range</code>
    <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"("</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">+</code> <code class="s2">"..."</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">+</code> <code class="s2">")"</code><code class="p">;</code> <code class="p">}</code>
<code class="p">};</code>

<code class="c1">// Here are example uses of this new Range class</code>
<code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>   <code class="c1">// Create a Range object; note the use of new</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>             <code class="c1">// =&gt; true: 2 is in the range</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>              <code class="c1">// =&gt; "(1...3)"</code>
<code class="p">[...</code><code class="nx">r</code><code class="p">]</code>                    <code class="c1">// =&gt; [1, 2, 3]; convert to an array via iterator</code></pre></div>

<p>It is worth comparing Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range1.js">9-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a> fairly carefully
and noting the differences between these two techniques for defining
classes.  First, notice that we renamed the <code>range()</code> factory function
to <code>Range()</code> when we converted it to a constructor. This is a very
common coding convention: constructor functions define, in a sense,
classes, and classes have names that (by convention) begin with capital
letters. Regular functions and methods have names that begin with
lowercase letters.</p>

<p>Next, notice that the <code>Range()</code> constructor is invoked (at the end
of the example) with the <code>new</code> keyword while the <code>range()</code> factory
function was invoked without it. <a data-type="xref" href="#range1.js">Example 9-1</a> uses regular function
invocation (<a data-type="xref" href="ch08.xhtml#functioninvocation">§8.2.1</a>) to create the new object, and
<a data-type="xref" href="#range2.js">Example 9-2</a> uses constructor invocation
(<a data-type="xref" href="ch08.xhtml#constructorinvocation">§8.2.3</a>). Because the <code>Range()</code> constructor is
invoked with <code>new</code>, it does not have to call <code>Object.create()</code> or take
any action to create a new object. The new object is automatically
created before the constructor is called, and it is accessible as the
<code>this</code> value. The <code>Range()</code> constructor merely has to initialize
<code>this</code>. Constructors do not even have to return the newly created
object. Constructor invocation automatically creates a new object,
invokes the constructor as a method of that object, and returns the
new object. The fact that constructor invocation is so different from
regular function invocation is another reason that we give
constructors names that start with capital letters. Constructors are
written to be invoked as constructors, with the <code>new</code> keyword, and
they usually won’t work properly if they are invoked as regular
functions. A naming convention that keeps constructor functions
distinct from regular functions helps programmers know when to use
<code>new</code>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198535520280">
<h5>Constructors and new.target</h5>
<p>Within<a data-type="indexterm" data-primary="new.target expression" id="idm46198535509928"/><a data-type="indexterm" data-primary="expressions" data-secondary="new.target expression" id="idm46198535509192"/><a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" data-tertiary="new.target expression" id="idm46198535508248"/><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" data-tertiary="new.target expression" id="idm46198535507064"/> a function body, you can tell whether the function has been
invoked as a constructor with the special expression <code>new.target</code>. If
the value of that expression is defined, then you know that the
function was invoked as a constructor, with the <code>new</code> keyword. When we
discuss subclasses in <a data-type="xref" href="#subclasses">§9.5</a>, we’ll see that <code>new.target</code> is
not always a reference to the constructor it is used in: it might also
refer to the constructor function of a subclass.</p>

<p>If <code>new.target</code> is <code>undefined</code>, then the containing function was
invoked as a function, without the <code>new</code> keyword. JavaScript’s various
error constructors can be invoked without <code>new</code>, and if you want to
emulate this feature in your own constructors, you can write them like
this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">C</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">new</code><code class="p">.</code><code class="nx">target</code><code class="p">)</code> <code class="k">return</code> <code class="k">new</code> <code class="nx">C</code><code class="p">();</code>
    <code class="c1">// initialization code goes here</code>
<code class="p">}</code></pre>

<p>This technique only works for constructors defined in this
old-fashioned way. Classes created with the <code>class</code> keyword do not
allow their constructors to be invoked without <code>new</code>.</p>
</div></aside>

<p>Another critical difference between Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range1.js">9-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a>  is
the way the prototype object is named. In the first example, the
prototype was <code>range.methods</code>. This was a convenient and descriptive
name, but arbitrary. In the second example, the prototype is
<code>Range.prototype</code>, and this name is mandatory. An invocation of the
<code>Range()</code> constructor automatically uses <code>Range.prototype</code> as the
prototype of the new Range object.</p>

<p>Finally, also note the things that do not change between Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range1.js">9-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a> : the range methods are defined and invoked in the
same way for both classes. Because <a data-type="xref" href="#range2.js">Example 9-2</a> demonstrates the
idiomatic way to create classes in versions of JavaScript before ES6,
it does not use the ES6 shorthand method syntax in the prototype
object and explicitly spells out the methods with the <code>function</code>
keyword. But you can see that the implementation of the methods is the
same in both examples.</p>

<p>Importantly, note that neither of the two range examples uses arrow
functions when defining constructors or methods. Recall from
<a data-type="xref" href="ch08.xhtml#arrowfunctions">§8.1.3</a> that functions defined in this way do not have a
<code>prototype</code> property and so cannot be used as constructors. Also,
arrow functions inherit the <code>this</code> keyword from the context in which
they are defined rather than setting it based on the object through which they
are invoked, and this makes them useless for methods because
the defining characteristic of methods is that they use <code>this</code> to
refer to the instance on which they were invoked.</p>

<p>Fortunately, the new ES6 class syntax doesn’t allow the option of
defining methods with arrow functions, so this is not a mistake that
you can accidentally make when using that syntax. We will cover the
ES6 <code>class</code> keyword soon, but first, there are more details to cover
about constructors.</p>








<section data-type="sect2" data-pdf-bookmark="9.2.1 Constructors, Class Identity, and instanceof"><div class="sect2" id="idm46198535464824">
<h2>9.2.1 Constructors, Class Identity, and instanceof</h2>

<p>As<a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" data-tertiary="constructors, class identity, and instanceof" id="idm46198535463128"/><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" data-tertiary="constructors, class identity, and instanceof" id="idm46198535461784"/><a data-type="indexterm" data-primary="instanceof operator" id="idm46198535460536"/> we’ve seen, the prototype object is fundamental to the identity of
a class: two objects are instances of the same class if and only if
they inherit from the same prototype object. The constructor function
that initializes the state of a new object is not fundamental: two
constructor functions may have <code>prototype</code> properties that point to
the same prototype object. Then, both constructors can be used to
create instances of the same class.</p>

<p>Even though constructors are not as fundamental as prototypes, the
constructor serves as the public face of a class. Most obviously, the
name of the constructor function is usually adopted as the name of the
class. We say, for example, that the <code>Range()</code> constructor creates
Range objects. More fundamentally, however, constructors are used
as the righthand operand of
the <code>instanceof</code> operator when testing objects for membership in a
class. If we have an object <code>r</code> and want to know if it is a Range
object, we can write:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">r</code> <code class="k">instanceof</code> <code class="nx">Range</code>   <code class="c1">// =&gt; true: r inherits from Range.prototype</code></pre>

<p>The <code>instanceof</code> operator was described in <a data-type="xref" href="ch04.xhtml#instanceof">§4.9.4</a>. The
lefthand operand should be the object that is being tested, and the
righthand operand should be a constructor function that names a
class. The expression <code>o instanceof C</code> evaluates to <code>true</code> if <code>o</code>
inherits from <code>C.prototype</code>. The inheritance need not be direct: if
<code>o</code> inherits from an object that inherits from an object that inherits
from <code>C.prototype</code>, the expression will still evaluate to <code>true</code>.</p>

<p>Technically speaking, in the previous code example, the <code>instanceof</code> operator is
not checking whether <code>r</code> was actually initialized by the <code>Range</code>
constructor. Instead, it is checking whether <code>r</code> inherits from
<code>Range.prototype</code>. If we define a function <code>Strange()</code> and set its
prototype to be the same as <code>Range.prototype</code>, then objects created
with <code>new Strange()</code> will count as Range objects as far as
<code>instanceof</code> is concerned (they won’t actually work as Range objects,
however, because their <code>from</code> and <code>to</code> properties have not been
initialized):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">Strange</code><code class="p">()</code> <code class="p">{}</code>
<code class="nx">Strange</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code>
<code class="k">new</code> <code class="nx">Strange</code><code class="p">()</code> <code class="k">instanceof</code> <code class="nx">Range</code>   <code class="c1">// =&gt; true</code></pre>

<p>Even though <code>instanceof</code> cannot actually verify the use of a
constructor, it still uses a constructor function as its righthand
side because constructors are the public identity of a class.</p>

<p>If you want to test the prototype chain of an object for a specific
prototype and do not want to use the constructor function as an
intermediary, you can use the <span class="keep-together"><code>isPrototypeOf()</code></span> method. In
<a data-type="xref" href="#range1.js">Example 9-1</a>, for example, we defined a class without a constructor
function, so there is no way to use <code>instanceof</code> with that
class. Instead, however, we could test whether an object <code>r</code> was a
member of that constructor-less class with this code:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">range</code><code class="p">.</code><code class="nx">methods</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">r</code><code class="p">);</code>  <code class="c1">// range.methods is the prototype object.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.2.2 The constructor Property"><div class="sect2" id="constructorproperty">
<h2>9.2.2 The constructor Property</h2>

<p>In<a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" data-tertiary="constructor property" id="Cccconst09"/><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" data-tertiary="constructor property" id="COcprop09"/> <a data-type="xref" href="#range2.js">Example 9-2</a>, we set <code>Range.prototype</code> to a new object that
contained the methods for our class. Although it was convenient to
express those methods as properties of a single object literal, it was
not actually necessary to create a new object. Any regular JavaScript
function (excluding arrow functions, generator functions, and async
functions) can be used as a constructor, and constructor
invocations need a <code>prototype</code> property. Therefore, every regular
JavaScript function<sup><a data-type="noteref" id="idm46198535317032-marker" href="ch09.xhtml#idm46198535317032">1</a></sup>
automatically has a <code>prototype</code> property. The value of this property
is an object that has a single, non-enumerable <code>constructor</code>
property. The value of the <code>constructor</code> property is the function
object:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">F</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{};</code> <code class="c1">// This is a function object.</code>
<code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nx">F</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code>   <code class="c1">// This is the prototype object associated with F.</code>
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">p</code><code class="p">.</code><code class="nx">constructor</code><code class="p">;</code> <code class="c1">// This is the function associated with the prototype.</code>
<code class="nx">c</code> <code class="o">===</code> <code class="nx">F</code>                <code class="c1">// =&gt; true: F.prototype.constructor === F for any F</code></pre>

<p>The existence of this predefined prototype object with its <code>constructor</code>
property means that objects typically inherit a <code>constructor</code> property that
refers to their constructor. Since constructors serve as the public identity of
a class, this constructor property gives the class of an object:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">F</code><code class="p">();</code>      <code class="c1">// Create an object o of class F</code>
<code class="nx">o</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">===</code> <code class="nx">F</code>   <code class="c1">// =&gt; true: the constructor property specifies the class</code></pre>

<p><a data-type="xref" href="#prototypefig">Figure 9-1</a> illustrates this relationship between the constructor
function, its prototype object, the back reference from the prototype
to the constructor, and the instances created with the constructor.</p>

<figure><div id="prototypefig" class="figure">
<img src="Images/js7e_0901.png" alt="js7e 0901" width="1019" height="280"/>
<h6><span class="label">Figure 9-1. </span>A constructor function, its prototype, and instances</h6>
</div></figure>

<p>Notice that <a data-type="xref" href="#prototypefig">Figure 9-1</a> uses our <code>Range()</code> constructor as an
example. In fact, however, the Range class defined in <a data-type="xref" href="#range2.js">Example 9-2</a>
overwrites the predefined <code>Range.prototype</code> object with an object of
its own. And the new prototype object it defines does not have a
<code>constructor</code> property. So instances of the Range class, as defined,
do not have a <code>constructor</code> property.  We can remedy this problem by
explicitly adding a constructor to the prototype:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="o">:</code> <code class="nx">Range</code><code class="p">,</code>  <code class="c1">// Explicitly set the constructor back-reference</code>

    <code class="cm">/* method definitions go here */</code>
<code class="p">};</code></pre>

<p>Another common technique that you are likely to see in older JavaScript
code is to use the predefined prototype object with its <code>constructor</code>
property and add methods to it one at a time with code<a data-type="indexterm" data-primary="" data-startref="Cconst09" id="idm46198535166888"/><a data-type="indexterm" data-primary="" data-startref="Cclass09" id="idm46198535166040"/><a data-type="indexterm" data-primary="" data-startref="COcprop09" id="idm46198535141624"/><a data-type="indexterm" data-primary="" data-startref="COcprop09" id="idm46198535140680"/> like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Extend the predefined Range.prototype object so we don't overwrite</code>
<code class="c1">// the automatically created Range.prototype.constructor property.</code>
<code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">includes</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code>
<code class="p">};</code>
<code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"("</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">+</code> <code class="s2">"..."</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">+</code> <code class="s2">")"</code><code class="p">;</code>
<code class="p">};</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="9.3 Classes with the class Keyword"><div class="sect1" id="es6classes">
<h1>9.3 Classes with the class Keyword</h1>

<p>Classes<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" id="Cckey09"/><a data-type="indexterm" data-primary="class keyword" id="class09"/><a data-type="indexterm" data-primary="keywords" data-secondary="class keyword" id="Kclass09"/><a data-type="indexterm" data-primary="ES6" data-secondary="class keyword" id="ESclass09"/> have been part of JavaScript since the very first version of
the language, but in ES6, they finally got their own syntax
with the introduction of the <code>class</code> keyword. <a data-type="xref" href="#range3.js">Example 9-3</a> shows what
our Range class looks like when written with this new <span class="keep-together">syntax.</span></p>
<div id="range3.js" data-type="example">
<h5><span class="label">Example 9-3. </span>The Range class rewritten using <em>class</em></h5>

<pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Range</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Store the start and end points (state) of this new range object.</code>
        <code class="c1">// These are noninherited properties that are unique to this object.</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// Return true if x is in the range, false otherwise</code>
    <code class="c1">// This method works for textual and Date ranges as well as numeric.</code>
    <code class="nx">includes</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// A generator function that makes instances of the class iterable.</code>
    <code class="c1">// Note that it only works for numeric ranges.</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// Return a string representation of the range</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb">...</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Here are example uses of this new Range class</code>
<code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>   <code class="c1">// Create a Range object</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>             <code class="c1">// =&gt; true: 2 is in the range</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>              <code class="c1">// =&gt; "(1...3)"</code>
<code class="p">[...</code><code class="nx">r</code><code class="p">]</code>                    <code class="c1">// =&gt; [1, 2, 3]; convert to an array via iterator</code></pre></div>

<p>It is important to understand that the classes defined in Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range3.js">9-3</a> work in exactly the same way. The
introduction of the <code>class</code> keyword to the language does not alter the
fundamental nature of JavaScript’s prototype-based classes. And
although <a data-type="xref" href="#range3.js">Example 9-3</a> uses the <code>class</code> keyword, the resulting Range
object is a constructor function, just like the version defined in
<a data-type="xref" href="#range2.js">Example 9-2</a>. The new <code>class</code> syntax is clean and convenient but is
best thought of as “syntactic sugar” for the more fundamental class
definition mechanism shown in <a data-type="xref" href="#range2.js">Example 9-2</a>.</p>

<p>Note the following things about the class syntax in <a data-type="xref" href="#range3.js">Example 9-3</a>:</p>

<ul>
<li>
<p>The class is declared with the <code>class</code> keyword, which is followed by
the name of class and a class body in curly braces.</p>
</li>
<li>
<p>The class body includes method definitions that use object literal
method shorthand (which we also used in <a data-type="xref" href="#range1.js">Example 9-1</a>), where the
<code>function</code> keyword is omitted. Unlike object literals, however, no
commas are used to separate the methods from each other. (Although
class bodies are superficially similar to object literals, they are
not the same thing. In particular, they do not support the
definition of properties with name/value pairs.)</p>
</li>
<li>
<p>The keyword <code>constructor</code> is used to define the constructor function
for the class. The function defined is not actually named
“constructor”, however. The <code>class</code> declaration statement defines a
new variable <code>Range</code> and assigns the value of this special
<code>constructor</code> function to that variable.</p>
</li>
<li>
<p>If your class does not need to do any initialization, you can omit
the <code>constructor</code> keyword and its body, and an empty constructor
function will be implicitly created for you.</p>
</li>
</ul>

<p>If you want to define a class that subclasses—or <em>inherits
from</em>—another class, you can use the <code>extends</code> keyword with the
<code>class</code> keyword:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// A Span is like a Range, but instead of initializing it with</code>
<code class="c1">// a start and an end, we initialize it with a start and a length</code>
<code class="kr">class</code> <code class="nx">Span</code> <code class="kr">extends</code> <code class="nx">Range</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">length</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">super</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">start</code> <code class="o">+</code> <code class="nx">length</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="kr">super</code><code class="p">(</code><code class="nx">start</code> <code class="o">+</code> <code class="nx">length</code><code class="p">,</code> <code class="nx">start</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Creating subclasses is a whole topic of its own. We’ll return to it,
and explain the <code>extends</code> and <code>super</code> keywords shown here, in
<a data-type="xref" href="#subclasses">§9.5</a>.</p>

<p>Like function declarations, class declarations have both statement and
expression forms. Just as we can write:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">square</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code> <code class="p">};</code>
<code class="nx">square</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>  <code class="c1">// =&gt; 9</code></pre>

<p>we can also write:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">Square</code> <code class="o">=</code> <code class="kr">class</code> <code class="p">{</code> <code class="nx">constructor</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">area</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code> <code class="p">};</code>
<code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">area</code>  <code class="c1">// =&gt; 9</code></pre>

<p>As with function definition expressions, class definition expressions
can include an optional class name. If you provide such a name, that
name is only defined within the class body itself.</p>

<p>Although function expressions are quite common (particularly with the
arrow function shorthand), in JavaScript programming, class definition
expressions are not something that you are likely to use much unless
you find yourself writing a function that takes a class as its
argument and returns a subclass.</p>

<p>We’ll conclude this introduction to the <code>class</code> keyword by mentioning
a couple of important things you should know that are not apparent
from <code>class</code> syntax:</p>

<ul>
<li>
<p>All<a data-type="indexterm" data-primary="strict mode" data-secondary="default application of" id="idm46198534657656"/><a data-type="indexterm" data-primary="use strict directive" data-secondary="default application of strict mode" id="idm46198534656648"/> code within the body of a <code>class</code> declaration is implicitly in
strict mode (<a data-type="xref" href="ch05.xhtml#strictmode">§5.6.3</a>), even if no <code>"use strict"</code> directive
appears. This means, for example, that you can’t use octal integer
literals or the <code>with</code> statement within class bodies and that you
are more likely to get syntax errors if you forget to declare a
variable before using it.</p>
</li>
<li>
<p>Unlike function declarations, class declarations are not
“hoisted.” Recall from <a data-type="xref" href="ch08.xhtml#functiondeclarations">§8.1.1</a> that function definitions
behave as if they had been moved to the top of the enclosing file or
enclosing function, meaning that you can invoke a function in code
that comes before the actual definition of the function. Although
class declarations are like function declarations in some ways, they
do not share this hoisting behavior: you <em>cannot</em> instantiate a
class before you declare it.</p>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="9.3.1 Static Methods"><div class="sect2" id="idm46198534650616">
<h2>9.3.1 Static Methods</h2>

<p>You<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="static methods" id="idm46198534649048"/><a data-type="indexterm" data-primary="methods" data-secondary="static methods" id="idm46198534647800"/><a data-type="indexterm" data-primary="static methods" id="idm46198534646856"/> can define a static method within a <code>class</code> body by prefixing the
method declaration with the <code>static</code> keyword. Static methods are
defined as properties of the constructor function rather than
properties of the prototype object.</p>

<p>For example, suppose we added the following code to <a data-type="xref" href="#range3.js">Example 9-3</a>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">static</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">matches</code> <code class="o">=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="sr">/^\((\d+)\.\.\.(\d+)\)$/</code><code class="p">);</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">matches</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Cannot parse Range from "</code><code class="si">${</code><code class="nx">s</code><code class="si">}</code><code class="sb">".`</code><code class="p">)</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="nb">parseInt</code><code class="p">(</code><code class="nx">matches</code><code class="p">[</code><code class="mi">1</code><code class="p">]),</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">matches</code><code class="p">[</code><code class="mi">2</code><code class="p">]));</code>
<code class="p">}</code></pre>

<p>The method defined by this code is <code>Range.parse()</code>, not
<code>Range.prototype.parse()</code>, and you must invoke it through the
constructor, not through an instance:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="nx">Range</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="s1">'(1...10)'</code><code class="p">);</code> <code class="c1">// Returns a new Range object</code>
<code class="nx">r</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="s1">'(1...10)'</code><code class="p">);</code>             <code class="c1">// TypeError: r.parse is not a function</code></pre>

<p>You’ll<a data-type="indexterm" data-primary="class methods" id="idm46198534552680"/><a data-type="indexterm" data-primary="methods" data-secondary="class versus instance methods" id="idm46198534552072"/> sometimes see static methods called <em>class methods</em> because
they are invoked using the name of the class/constructor. When this
term is used, it is to contrast class methods with the<a data-type="indexterm" data-primary="instance methods" id="idm46198534488552"/> regular
<em>instance methods</em> that are invoked on instances of the class.
Because static methods are invoked on the constructor rather than on
any particular instance, it almost never makes sense to use the <code>this</code>
keyword in a static method.</p>

<p>We’ll see examples of static methods in <a data-type="xref" href="#Complex.js">Example 9-4</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.3.2 Getters, Setters, and other Method Forms"><div class="sect2" id="idm46198534485400">
<h2>9.3.2 Getters, Setters, and other Method Forms</h2>

<p>Within<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="getters, setters, and other method forms" id="idm46198534483880"/><a data-type="indexterm" data-primary="getter methods" id="idm46198534482536"/><a data-type="indexterm" data-primary="setter methods" id="idm46198534481864"/> a <code>class</code> body, you can define getter and setter methods
(<a data-type="xref" href="ch06.xhtml#gettersandsetters">§6.10.6</a>) just as you can in object literals. The only
difference is that in class bodies, you don’t put a comma after the
getter or setter. <a data-type="xref" href="#Complex.js">Example 9-4</a> includes a practical example of a
getter method in a class.</p>

<p>In general, all of the<a data-type="indexterm" data-primary="shorthand methods" id="idm46198534540968"/><a data-type="indexterm" data-primary="methods" data-secondary="shorthand methods" id="idm46198534540232"/> shorthand method definition syntaxes
allowed in object literals are also allowed in class bodies. This
includes generator methods (marked with <code>*</code>) and methods whose names
are the value of an expression in square brackets. In fact, you’ve
already seen (in <a data-type="xref" href="#range3.js">Example 9-3</a>) a generator method with a computed
name that makes the Range class iterable:</p>

<pre data-type="programlisting" data-code-language="js"><code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.3.3 Public, Private, and Static Fields"><div class="sect2" id="idm46198534402296">
<h2>9.3.3 Public, Private, and Static Fields</h2>

<p>In<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="public private, and static fields" id="Ckeypub09"/><a data-type="indexterm" data-primary="public fields" id="idm46198534439224"/><a data-type="indexterm" data-primary="private fields" id="idm46198534438552"/><a data-type="indexterm" data-primary="static fields" id="idm46198534437880"/><a data-type="indexterm" data-primary="fields, public, private, and static" id="idm46198534437208"/> the discussion here of classes defined with the <code>class</code> keyword,
we have only described the definition of methods within the class
body. The ES6 standard only allows the creation of methods (including
getters, setters, and generators) and static methods; it does not
include syntax for defining fields. If you want to define a field
(which is just an object-oriented synonym for “property”) on a class
instance, you must do that in the constructor function or in one of
the methods. And if you want to define a static field for a class, you
must do that outside the class body, after the class has been
defined. <a data-type="xref" href="#Complex.js">Example 9-4</a> includes examples of both kinds of fields.</p>

<p>Standardization is underway, however, for extended class syntax that
allows the definition of instance and static fields, in both public
and private forms. The code shown in the rest of this section is not
yet standard JavaScript as of early 2020 but is already supported in Chrome
 and partially supported (public instance fields only) in Firefox. The
syntax for public instance fields is in common use by JavaScript
programmers using the React framework and the Babel transpiler.</p>

<p>Suppose you’re writing a class like this one, with a constructor that
initializes three fields:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Buffer</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">capacity</code> <code class="o">=</code> <code class="mi">4096</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">buffer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">capacity</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>With the new instance field syntax that is likely to be standardized,
you could instead write:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Buffer</code> <code class="p">{</code>
    <code class="nx">size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="nx">capacity</code> <code class="o">=</code> <code class="mi">4096</code><code class="p">;</code>
    <code class="nx">buffer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">capacity</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>The field initialization code has moved out of the constructor and now
appears directly in the class body. (That code is still run as part of
the constructor, of course. If you do not define a constructor, the
fields are initialized as part of the implicitly created constructor.)
The <code>this.</code> prefixes that appeared on the lefthand side of the
assignments are gone, but note that you still must use
<code>this.</code> to refer to these fields, even on the righthand side of the
initializer assignments. The advantage of initializing your instance
fields in this way is that this syntax allows (but does not require)
you to put the initializers up at the top of the class definition,
making it clear to readers exactly what fields will hold the state of
each instance. You can declare fields without an initializer by just
writing the name of the field followed by a semicolon. If you do that,
the initial value of the field will be <code>undefined</code>. It is better style
to always make the initial value explicit for all of your class
fields.</p>

<p>Before the addition of this field syntax, class bodies looked a lot
like object literals using shortcut method syntax, except that the
commas had been removed. This field syntax—with equals signs and
semicolons instead of colons and commas—makes it clear that
class bodies are not at all the same as object literals.</p>

<p>The same proposal that seeks to standardize these instance fields also
defines private instance fields. If you use the instance field
initialization syntax shown in the previous example to define a field whose name begins
with <code>#</code> (which is not normally a legal character in JavaScript
identifiers), that field will be usable (with the <code>#</code> prefix) within
the class body but will be invisible and inaccessible (and therefore
immutable) to any code outside of the class body. If, for the preceding hypothetical Buffer class, you wanted to ensure that users of the
class could not inadvertently modify the <code>size</code> field of an instance,
you could use a private <code>#size</code> field instead, then define a getter
function to provide read-only access to the value:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Buffer</code> <code class="p">{</code>
    <code class="err">#</code><code class="nx">size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">size</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>Note that private fields must be declared using this new field syntax
before they can be used. You can’t just write <code>this.#size = 0;</code> in the
constructor of a class unless you include a “declaration” of the field
directly in the class body.</p>

<p>Finally, a related proposal seeks to standardize the use of the
<code>static</code> keyword for fields. If you add <code>static</code> before a public or
private field declaration, those fields will be created as properties
of the constructor function instead of properties of
instances. Consider the static <code>Range.parse()</code> method we’ve defined. It included a fairly complex regular expression that might be
good to factor out into its own static field. With the proposed new
static field syntax, we could do that like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">static</code> <code class="nx">integerRangePattern</code> <code class="o">=</code> <code class="sr">/^\((\d+)\.\.\.(\d+)\)$/</code><code class="p">;</code>
<code class="kr">static</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">matches</code> <code class="o">=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="nx">Range</code><code class="p">.</code><code class="nx">integerRangePattern</code><code class="p">);</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">matches</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Cannot parse Range from "</code><code class="si">${</code><code class="nx">s</code><code class="si">}</code><code class="sb">".`</code><code class="p">)</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="nb">parseInt</code><code class="p">(</code><code class="nx">matches</code><code class="p">[</code><code class="mi">1</code><code class="p">]),</code> <code class="nx">matches</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code>
<code class="p">}</code></pre>

<p>If we wanted this static field to be accessible only within the class,
we could make it private using a name like <code>#pattern</code>.<a data-type="indexterm" data-primary="" data-startref="Ckeypub09" id="idm46198534186536"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.3.4 Example: A Complex Number Class"><div class="sect2" id="idm46198534441880">
<h2>9.3.4 Example: A Complex Number Class</h2>

<p><a data-type="xref" href="#Complex.js">Example 9-4</a> defines<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="complex number class example" id="Ckeycomp09"/> a class to represent complex numbers. The
class is a relatively simple one, but it includes instance methods
(including getters), static methods, instance fields, and static
fields. It includes some commented-out code demonstrating how we might
use the not-yet-standard syntax for defining instance fields and
static fields within the class body.</p>
<div id="Complex.js" data-type="example">
<h5><span class="label">Example 9-4. </span>Complex.js: a complex number class</h5>

<pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
<code class="cm"> * Instances of this Complex class represent complex numbers.</code>
<code class="cm"> * Recall that a complex number is the sum of a real number and an</code>
<code class="cm"> * imaginary number and that the imaginary number i is the square root of -1.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">Complex</code> <code class="p">{</code>
    <code class="c1">// Once class field declarations are standardized, we could declare</code>
    <code class="c1">// private fields to hold the real and imaginary parts of a complex number</code>
    <code class="c1">// here, with code like this:</code>
    <code class="c1">//</code>
    <code class="c1">// #r = 0;</code>
    <code class="c1">// #i = 0;</code>

    <code class="c1">// This constructor function defines the instance fields r and i on every</code>
    <code class="c1">// instance it creates. These fields hold the real and imaginary parts of</code>
    <code class="c1">// the complex number: they are the state of the object.</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">real</code><code class="p">,</code> <code class="nx">imaginary</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">=</code> <code class="nx">real</code><code class="p">;</code>       <code class="c1">// This field holds the real part of the number.</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">=</code> <code class="nx">imaginary</code><code class="p">;</code>  <code class="c1">// This field holds the imaginary part.</code>
    <code class="p">}</code>

    <code class="c1">// Here are two instance methods for addition and multiplication</code>
    <code class="c1">// of complex numbers. If c and d are instances of this class, we</code>
    <code class="c1">// might write c.plus(d) or d.times(c)</code>
    <code class="nx">plus</code><code class="p">(</code><code class="nx">that</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">+</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">+</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="nx">times</code><code class="p">(</code><code class="nx">that</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code> <code class="o">-</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code><code class="p">,</code>
                           <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="c1">// And here are static variants of the complex arithmetic methods.</code>
    <code class="c1">// We could write Complex.sum(c,d) and Complex.product(c,d)</code>
    <code class="kr">static</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">c</code><code class="p">.</code><code class="nx">plus</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="p">}</code>
    <code class="kr">static</code> <code class="nx">product</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">c</code><code class="p">.</code><code class="nx">times</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="p">}</code>

    <code class="c1">// These are some instance methods that are defined as getters</code>
    <code class="c1">// so they're used like fields. The real and imaginary getters would</code>
    <code class="c1">// be useful if we were using private fields this.#r and this.#i</code>
    <code class="nx">get</code> <code class="nx">real</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">get</code> <code class="nx">imaginary</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">get</code> <code class="nx">magnitude</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="p">);</code> <code class="p">}</code>

    <code class="c1">// Classes should almost always have a toString() method</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="si">}</code><code class="sb">,</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="si">}</code><code class="sb">}`</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// It is often useful to define a method for testing whether</code>
    <code class="c1">// two instances of your class represent the same value</code>
    <code class="nx">equals</code><code class="p">(</code><code class="nx">that</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">that</code> <code class="k">instanceof</code> <code class="nx">Complex</code> <code class="o">&amp;&amp;</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">===</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code> <code class="o">&amp;&amp;</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">===</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// Once static fields are supported inside class bodies, we could</code>
    <code class="c1">// define a useful Complex.ZERO constant like this:</code>
    <code class="c1">// static ZERO = new Complex(0,0);</code>
<code class="p">}</code>

<code class="c1">// Here are some class fields that hold useful predefined complex numbers.</code>
<code class="nx">Complex</code><code class="p">.</code><code class="nx">ZERO</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">0</code><code class="p">);</code>
<code class="nx">Complex</code><code class="p">.</code><code class="nx">ONE</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">0</code><code class="p">);</code>
<code class="nx">Complex</code><code class="p">.</code><code class="nx">I</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">);</code></pre></div>

<p>With the Complex class of <a data-type="xref" href="#Complex.js">Example 9-4</a> defined, we can use the constructor,
instance fields, instance methods, class fields, and class methods with code
like<a data-type="indexterm" data-primary="" data-startref="Cckey09" id="idm46198534170712"/><a data-type="indexterm" data-primary="" data-startref="class09" id="idm46198534169864"/><a data-type="indexterm" data-primary="" data-startref="Kclass09" id="idm46198534168920"/><a data-type="indexterm" data-primary="" data-startref="ESclass09" id="idm46198534167976"/><a data-type="indexterm" data-primary="" data-startref="Ckeycomp09" id="idm46198534167032"/> this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">);</code>     <code class="c1">// Create a new object with the constructor</code>
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">i</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">r</code><code class="p">);</code> <code class="c1">// Use instance fields of c</code>
<code class="nx">c</code><code class="p">.</code><code class="nx">plus</code><code class="p">(</code><code class="nx">d</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code>           <code class="c1">// =&gt; "{5,5}"; use instance methods</code>
<code class="nx">c</code><code class="p">.</code><code class="nx">magnitude</code>                    <code class="c1">// =&gt; Math.hypot(2,3); use a getter function</code>
<code class="nx">Complex</code><code class="p">.</code><code class="nx">product</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code>          <code class="c1">// =&gt; new Complex(0, 13); a static method</code>
<code class="nx">Complex</code><code class="p">.</code><code class="nx">ZERO</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>        <code class="c1">// =&gt; "{0,0}"; a static property</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="9.4 Adding Methods to Existing Classes"><div class="sect1" id="augmentingclasses">
<h1>9.4 Adding Methods to Existing Classes</h1>

<p>JavaScript’s<a data-type="indexterm" data-primary="classes" data-secondary="adding methods to existing classes" id="idm46198533749624"/><a data-type="indexterm" data-primary="methods" data-secondary="adding methods to existing classes" id="idm46198533748584"/> prototype-based inheritance mechanism is dynamic: an
object inherits properties from its prototype, even if the properties
of the prototype change after the object is created. This means that
we can augment JavaScript classes simply by adding new methods to
their prototype objects.</p>

<p>Here, for example, is code that adds a method for computing the complex conjugate to the Complex class of <a data-type="xref" href="#Complex.js">Example 9-4</a>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Return a complex number that is the complex conjugate of this one.</code>
<code class="nx">Complex</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">conj</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">,</code> <code class="o">-</code><code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="p">);</code> <code class="p">};</code></pre>

<p>The prototype object of built-in JavaScript classes is also open like
this, which means that we can add methods to numbers, strings, arrays,
functions, and so on. This is useful for implementing new language
features in older versions of the language:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// If the new String method startsWith() is not already defined...</code>
<code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...then define it like this using the older indexOf() method.</code>
    <code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">startsWith</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="o">===</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">};</code>
<code class="p">}</code></pre>

<p>Here is another example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Invoke the function f this many times, passing the iteration number</code>
<code class="c1">// For example, to print "hello" 3 times:</code>
<code class="c1">//     let n = 3;</code>
<code class="c1">//     n.times(i =&gt; { console.log(`hello ${i}`); });</code>
<code class="nb">Number</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">times</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">valueOf</code><code class="p">();</code>
    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">f</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">context</code><code class="p">,</code> <code class="nx">i</code><code class="p">);</code>
<code class="p">};</code></pre>

<p>Adding methods to the prototypes of built-in types like this is
generally considered to be a bad idea because it will cause confusion
and compatibility problems in the future if a new version of
JavaScript defines a method with the same name. It is even possible to
add methods to <code>Object.prototype</code>, making them available for all
objects. But this is never a good thing to do because properties added
to <code>Object.prototype</code> are visible to <code>for/in</code> loops (though you can
avoid this by using <code>Object.defineProperty()</code>
[<a data-type="xref" href="ch14.xhtml#propertydescriptors">§14.1</a>] to make the new property non-enumerable).</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="9.5 Subclasses"><div class="sect1" id="subclasses">
<h1>9.5 Subclasses</h1>

<p>In<a data-type="indexterm" data-primary="subclasses" data-secondary="overview of" id="idm46198533592680"/><a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="overview of" id="idm46198533591672"/> object-oriented programming, a class B can <em>extend</em> or <em>subclass</em>
another class A. We say that A is the <em>superclass</em> and B is the
<em>subclass</em>. Instances of B inherit the methods of A. The class B can
define its own methods, some of which may <em>override</em> methods of the
same name defined by class A. If a method of B overrides a method of
A, the overriding method in B often needs to invoke the overridden
method in A. Similarly, the subclass constructor <code>B()</code> must typically
invoke the superclass constructor <code>A()</code> in order to ensure that
instances are completely initialized.</p>

<p>This section starts by showing how to define subclasses the old,
pre-ES6 way, and then quickly moves on to demonstrate subclassing
using the <code>class</code> and <code>extends</code> keywords and superclass constructor
method invocation with the <code>super</code> keyword. Next is a
subsection about avoiding subclasses and relying on object
composition instead of inheritance. The section ends with an extended
example that defines a hierarchy of Set classes and demonstrates how
abstract classes can be used to separate interface from
implementation.</p>








<section data-type="sect2" data-pdf-bookmark="9.5.1 Subclasses and Prototypes"><div class="sect2" id="idm46198533497944">
<h2>9.5.1 Subclasses and Prototypes</h2>

<p>Suppose<a data-type="indexterm" data-primary="subclasses" data-secondary="prototypes and" id="idm46198533496184"/><a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="subclasses and prototypes" id="idm46198533495176"/> we wanted to define a Span subclass of the Range class from
<a data-type="xref" href="#range2.js">Example 9-2</a>. This subclass will work just like a Range, but instead
of initializing it with a start and an end, we’ll instead specify a
start and a distance, or span. An instance of this Span class is also
an instance of the Range superclass. A span instance inherits a
customized <code>toString()</code> method from <code>Span.prototype</code>, but in order to
be a subclass of Range, it must also inherit methods (such as
<code>includes()</code>) from <code>Range.prototype</code>.</p>
<div id="Span.js" data-type="example">
<h5><span class="label">Example 9-5. </span>Span.js: a simple subclass of Range</h5>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// This is the constructor function for our subclass</code>
<code class="kd">function</code> <code class="nx">Span</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">span</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">span</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">start</code> <code class="o">+</code> <code class="nx">span</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">start</code> <code class="o">+</code> <code class="nx">span</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Ensure that the Span prototype inherits from the Range prototype</code>
<code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>

<code class="c1">// We don't want to inherit Range.prototype.constructor, so we</code>
<code class="c1">// define our own constructor property.</code>
<code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">=</code> <code class="nx">Span</code><code class="p">;</code>

<code class="c1">// By defining its own toString() method, Span overrides the</code>
<code class="c1">// toString() method that it would otherwise inherit from Range.</code>
<code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb">... +</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">-</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code>
<code class="p">};</code></pre></div>

<p>In order to make Span a subclass of Range, we need to arrange for
<code>Span.prototype</code> to inherit from <code>Range.prototype</code>. The key line of
code in the preceding example is this one, and if it makes sense to you, you
understand how subclasses work in JavaScript:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code></pre>

<p>Objects created with the <code>Span()</code> constructor will inherit from the
<code>Span.prototype</code> object. But we created that object to inherit from
<code>Range.prototype</code>, so Span objects will inherit from both
<code>Span.prototype</code> and <code>Range.prototype</code>.</p>

<p>You may notice that our <code>Span()</code> constructor sets the same <code>from</code> and
<code>to</code> properties that the <code>Range()</code> constructor does and so does not
need to invoke the <code>Range()</code> constructor to initialize the new
object. Similarly, Span’s <code>toString()</code> method completely re-implements
the string conversion without needing to call Range’s version of
<code>toString()</code>. This makes Span a special case, and we can only really
get away with this kind of subclassing because we know the
implementation details of the superclass. A robust subclassing
mechanism needs to allow classes to invoke the methods and constructor
of their superclass, but prior to ES6, JavaScript did not have a
simple way to do these things.</p>

<p>Fortunately, ES6 solves these problems with the <code>super</code> keyword as
part of the <code>class</code> syntax. The next section demonstrates how it
works.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.5.2 Subclasses with extends and super"><div class="sect2" id="extendsandsuper">
<h2>9.5.2 Subclasses with extends and super</h2>

<p>In<a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="with extends clause" id="Csubext09"/><a data-type="indexterm" data-primary="subclasses" data-secondary="with extends clause" id="subext09"/><a data-type="indexterm" data-primary="ES6" data-secondary="subclasses with extends clause" id="ESsubext09"/> ES6 and later, you can create a superclass simply by adding an
<code>extends</code> clause to a class declaration, and you can do this even for
built-in classes:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// A trivial Array subclass that adds getters for the first and last elements.</code>
<code class="kr">class</code> <code class="nx">EZArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
    <code class="nx">get</code> <code class="nx">first</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="p">}</code>
    <code class="nx">get</code> <code class="nx">last</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">];</code> <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">EZArray</code><code class="p">();</code>
<code class="nx">a</code> <code class="k">instanceof</code> <code class="nx">EZArray</code>  <code class="c1">// =&gt; true: a is subclass instance</code>
<code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">Array</code>    <code class="c1">// =&gt; true: a is also a superclass instance.</code>
<code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">);</code>      <code class="c1">// a.length == 4; we can use inherited methods</code>
<code class="nx">a</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>               <code class="c1">// =&gt; 4: another inherited method</code>
<code class="nx">a</code><code class="p">.</code><code class="nx">first</code>               <code class="c1">// =&gt; 1: first getter defined by subclass</code>
<code class="nx">a</code><code class="p">.</code><code class="nx">last</code>                <code class="c1">// =&gt; 3: last getter defined by subclass</code>
<code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>                  <code class="c1">// =&gt; 2: regular array access syntax still works.</code>
<code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>      <code class="c1">// =&gt; true: subclass instance really is an array</code>
<code class="nx">EZArray</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>    <code class="c1">// =&gt; true: subclass inherits static methods, too!</code></pre>

<p>This EZArray subclass defines two simple getter methods. Instances of
EZArray behave like ordinary arrays, and we can use inherited methods
and properties like <code>push()</code>, <code>pop()</code>, and <code>length</code>. But we can also
use the <code>first</code> and <code>last</code> getters defined in the subclass. Not only
are instance methods like <code>pop()</code> inherited, but static methods like
<code>Array.isArray</code> are also inherited. This is a new feature enabled by
ES6 class syntax: <code>EZArray()</code> is a function, but it inherits from
<code>Array()</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// EZArray inherits instance methods because EZArray.prototype</code>
<code class="c1">// inherits from Array.prototype</code>
<code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">EZArray</code><code class="p">.</code><code class="nx">prototype</code><code class="p">)</code> <code class="c1">// =&gt; true</code>

<code class="c1">// And EZArray inherits static methods and properties because</code>
<code class="c1">// EZArray inherits from Array. This is a special feature of the</code>
<code class="c1">// extends keyword and is not possible before ES6.</code>
<code class="nb">Array</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">EZArray</code><code class="p">)</code> <code class="c1">// =&gt; true</code></pre>

<p>Our EZArray subclass is too simple to be very instructive.
<a data-type="xref" href="#TypedMap.js">Example 9-6</a> is a more fully fleshed-out example. It defines a
TypedMap subclass of the built-in Map class that adds type checking to
ensure that the keys and values of the map are of the specified types
(according to <code>typeof</code>). Importantly, this example demonstrates the
use of the <code>super</code> keyword to invoke the constructor and methods of
the superclass.</p>
<div id="TypedMap.js" data-type="example">
<h5><span class="label">Example 9-6. </span>TypedMap.js: a subclass of Map that checks key and value types</h5>

<pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">TypedMap</code> <code class="kr">extends</code> <code class="nx">Map</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">keyType</code><code class="p">,</code> <code class="nx">valueType</code><code class="p">,</code> <code class="nx">entries</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// If entries are specified, check their types</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">entries</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">v</code><code class="p">]</code> <code class="k">of</code> <code class="nx">entries</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">k</code> <code class="o">!==</code> <code class="nx">keyType</code> <code class="o">||</code> <code class="k">typeof</code> <code class="nx">v</code> <code class="o">!==</code> <code class="nx">valueType</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Wrong type for entry [</code><code class="si">${</code><code class="nx">k</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="nx">v</code><code class="si">}</code><code class="sb">]`</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>

        <code class="c1">// Initialize the superclass with the (type-checked) initial entries</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">entries</code><code class="p">);</code>

        <code class="c1">// And then initialize this subclass by storing the types</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">keyType</code> <code class="o">=</code> <code class="nx">keyType</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">valueType</code> <code class="o">=</code> <code class="nx">valueType</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// Now redefine the set() method to add type checking for any</code>
    <code class="c1">// new entries added to the map.</code>
    <code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Throw an error if the key or value are of the wrong type</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">keyType</code> <code class="o">&amp;&amp;</code> <code class="k">typeof</code> <code class="nx">key</code> <code class="o">!==</code> <code class="k">this</code><code class="p">.</code><code class="nx">keyType</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb"> is not of type </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">keyType</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">valueType</code> <code class="o">&amp;&amp;</code> <code class="k">typeof</code> <code class="nx">value</code> <code class="o">!==</code> <code class="k">this</code><code class="p">.</code><code class="nx">valueType</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb"> is not of type </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">valueType</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="c1">// If the types are correct, we invoke the superclass's version of</code>
        <code class="c1">// the set() method, to actually add the entry to the map. And we</code>
        <code class="c1">// return whatever the superclass method returns.</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>

<p>The first two arguments to the <code>TypedMap()</code> constructor are the
desired key and value types. These should be strings, such as “number”
and “boolean”, that the <code>typeof</code> operator returns. You can also specify
a third argument: an array (or any iterable object) of <code>[key,value]</code>
arrays that specify the initial entries in the map. If you specify any
initial entries, then the first thing the constructor does is verify
that their types are correct. Next, the constructor invokes the
superclass constructor, using the <code>super</code> keyword as if it was a
function name. The <code>Map()</code> constructor takes one optional argument: an
iterable object of <code>[key,value]</code> arrays. So the optional third
argument of the <code>TypedMap()</code> constructor is the optional first
argument to the <code>Map()</code> constructor, and we pass it to that superclass
constructor with <code>super(entries)</code>.</p>

<p>After invoking the superclass constructor to initialize superclass
state, the <span class="keep-together"><code>TypedMap()</code></span> constructor next initializes its own subclass
state by setting <code>this.keyType</code> and <code>this.valueType</code> to the specified
types. It needs to set these properties so that it can use them again
in the <code>set()</code> method.</p>

<p>There are a few important rules that you will need to know about using <code>super()</code> in constructors:</p>

<ul>
<li>
<p>If you define a class with the <code>extends</code> keyword, then the
constructor for your class must use <code>super()</code> to invoke the
superclass constructor.</p>
</li>
<li>
<p>If you don’t define a constructor in your subclass, one will be
defined automatically for you. This implicitly defined constructor
simply takes whatever values are passed to it and passes those
values to <code>super()</code>.</p>
</li>
<li>
<p>You may not use the <code>this</code> keyword in your constructor until after
you have invoked the superclass constructor with <code>super()</code>. This
enforces a rule that superclasses get to initialize themselves
before subclasses do.</p>
</li>
<li>
<p>The special expression <code>new.target</code> is undefined in functions that
are invoked without the <code>new</code> keyword. In constructor functions,
however, <code>new.target</code> is a reference to the constructor that was
invoked. When a subclass constructor is invoked and uses <code>super()</code>
to invoke the superclass constructor, that superclass constructor
will see the subclass constructor as the value of <code>new.target</code>. A
well-designed superclass should not need to know whether it has been
subclassed, but it might be useful to be able to use
<code>new.target.name</code> in logging messages, for example.</p>
</li>
</ul>

<p>After the constructor, the next part of <a data-type="xref" href="#TypedMap.js">Example 9-6</a> is a method
named <code>set()</code>. The Map superclass defines a method named <code>set()</code> to
add a new entry to the map. We say that this <code>set()</code> method in
TypedMap <em>overrides</em> the <code>set()</code> method of its superclass. This simple
TypedMap subclass doesn’t know anything about adding new entries to
map, but it does know how to check types, so that is what it does
first, verifying that the key and value to be added to the map have
the correct types and throwing an error if they do not. This <code>set()</code>
method doesn’t have any way to add the key and value to the map
itself, but that is what the superclass <code>set()</code> method is for. So we
use the <code>super</code> keyword again to invoke the superclass’s version of
the method. In this context, <code>super</code> works much like the <code>this</code>
keyword does: it refers to the current object but allows access to
overridden methods defined in the superclass.</p>

<p>In constructors, you are required to invoke the superclass constructor
before you can access <code>this</code> and initialize the new object
yourself. There are no such rules when you override a method. A method
that overrides a superclass method is not required to invoke the
superclass method. If it does use <code>super</code> to invoke the overridden
method (or any method) in the superclass, it can do that at the
beginning or the middle or the end of the overriding method.</p>

<p>Finally, before we leave the TypedMap example behind, it is worth
noting that this class is an ideal candidate for the use of private
fields. As the class is written now, a user could change the
<code>keyType</code> or <code>valueType</code> properties to subvert the type checking. Once
private fields are supported, we could change these properties to
<code>#keyType</code> and <code>#valueType</code> so that they could not be altered from the
outside.<a data-type="indexterm" data-primary="" data-startref="ESsubext09" id="idm46198532826424"/><a data-type="indexterm" data-primary="" data-startref="subext09" id="idm46198532825448"/><a data-type="indexterm" data-primary="" data-startref="Csubext09" id="idm46198532824504"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.5.3 Delegation Instead of Inheritance"><div class="sect2" id="idm46198533299720">
<h2>9.5.3 Delegation Instead of Inheritance</h2>

<p>The<a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="delegation versus inheritance" id="idm46198532821960"/><a data-type="indexterm" data-primary="subclasses" data-secondary="delegation versus inheritance" id="idm46198532820712"/><a data-type="indexterm" data-primary="delegation" id="idm46198532819752"/><a data-type="indexterm" data-primary="inheritance" id="idm46198532819080"/> <code>extends</code> keyword makes it easy to create subclasses. But that
does not mean that you <em>should</em> create lots of subclasses. If you want
to write a class that shares the behavior of some other class, you can
try to inherit that behavior by creating a subclass. But it is often
easier and more flexible to get that desired behavior into your class
by having your class create an instance of the other class and simply
delegating to that instance as needed. You create a new class not by
subclassing, but instead by wrapping or “composing” other
classes. This delegation approach is often called “composition,” and
it is an oft-quoted maxim of object-oriented programming that one
should “favor composition over inheritance.”<sup><a data-type="noteref" id="idm46198532816792-marker" href="ch09.xhtml#idm46198532816792">2</a></sup></p>

<p>Suppose, for example, we wanted a Histogram class that behaves
something like <span class="keep-together">JavaScript’s</span> Set class, except that instead of just
keeping track of whether a value has been added to set or not, it
instead maintains a count of the number of times the value has been
added. Because the API for this Histogram class is similar to Set, we
might consider subclassing Set and adding a <code>count()</code> method. On the
other hand, once we start thinking about how we might implement this
<code>count()</code> method, we might realize that the Histogram class is more
like a Map than a Set because it needs to maintain a mapping between
values and the number of times they have been added. So instead of
subclassing Set, we can create a class that defines a Set-like
API but implements those methods by delegating to an internal Map
object. <a data-type="xref" href="#Histogram.js">Example 9-7</a> shows how we could do this.</p>
<div id="Histogram.js" data-type="example">
<h5><span class="label">Example 9-7. </span>Histogram.js: a Set-like class implemented with delegation</h5>

<pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
<code class="cm"> * A Set-like class that keeps track of how many times a value has</code>
<code class="cm"> * been added. Call add() and remove() like you would for a Set, and</code>
<code class="cm"> * call count() to find out how many times a given value has been added.</code>
<code class="cm"> * The default iterator yields the values that have been added at least</code>
<code class="cm"> * once. Use entries() if you want to iterate [value, count] pairs.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">Histogram</code> <code class="p">{</code>
    <code class="c1">// To initialize, we just create a Map object to delegate to</code>
    <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code> <code class="p">}</code>

    <code class="c1">// For any given key, the count is the value in the Map, or zero</code>
    <code class="c1">// if the key does not appear in the Map.</code>
    <code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">||</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// The Set-like method has() returns true if the count is non-zero</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// The size of the histogram is just the number of entries in the Map.</code>
    <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// To add a key, just increment its count in the Map.</code>
    <code class="nx">add</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code> <code class="p">}</code>

    <code class="c1">// Deleting a key is a little trickier because we have to delete</code>
    <code class="c1">// the key from the Map if the count goes back down to zero.</code>
    <code class="k">delete</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">count</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="c1">// Iterating a Histogram just returns the keys stored in it</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">keys</code><code class="p">();</code> <code class="p">}</code>

    <code class="c1">// These other iterator methods just delegate to the Map object</code>
    <code class="nx">keys</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">keys</code><code class="p">();</code> <code class="p">}</code>
    <code class="nx">values</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">values</code><code class="p">();</code> <code class="p">}</code>
    <code class="nx">entries</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">entries</code><code class="p">();</code> <code class="p">}</code>
<code class="p">}</code></pre></div>

<p>All the <code>Histogram()</code> constructor does in <a data-type="xref" href="#Histogram.js">Example 9-7</a> is create a
Map object. And most of the methods are one-liners that just delegate
to a method of the map, making the implementation quite
simple. Because we used delegation rather than inheritance, a
Histogram object is not an instance of Set or Map. But Histogram
implements a number of commonly used Set methods, and in an untyped
language like JavaScript, that is often good enough: a formal
inheritance relationship is sometimes nice, but often optional.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="9.5.4 Class Hierarchies and Abstract Classes"><div class="sect2" id="idm46198532805480">
<h2>9.5.4 Class Hierarchies and Abstract Classes</h2>

<p><a data-type="xref" href="#TypedMap.js">Example 9-6</a> demonstrated<a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="class hierarchies and abstract classes" id="Csubhier09"/><a data-type="indexterm" data-primary="subclasses" data-secondary="class hierarchies and abstract classes" id="Shier09"/><a data-type="indexterm" data-primary="abstract classes" id="abstc09"/> how we can subclass Map. <a data-type="xref" href="#Histogram.js">Example 9-7</a>
demonstrated how we can instead delegate to a Map object without
actually subclassing anything. Using JavaScript classes to encapsulate
data and modularize your code is often a great technique, and you may
find yourself using the <code>class</code> keyword frequently. But you may find
that you prefer composition to inheritance and that you rarely need to
use <code>extends</code> (except when you’re using a library or framework that
requires you to extend its base classes).</p>

<p>There are some circumstances when multiple levels of subclassing are
appropriate, however, and we’ll end this chapter with an extended
example that demonstrates a hierarchy of classes representing
different kinds of sets. (The set classes defined in <a data-type="xref" href="#sets.js">Example 9-8</a> are
similar to, but not completely compatible with, JavaScript’s built-in
Set class.)</p>

<p><a data-type="xref" href="#sets.js">Example 9-8</a> defines lots of subclasses, but it also demonstrates how
you can define <em>abstract classes</em>—classes that do not include a
complete implementation—to serve as a common superclass for a group
of related subclasses. An abstract superclass can define a partial
implementation that all subclasses inherit and share. The subclasses,
then, only need to define their own unique behavior by implementing
the abstract methods defined—but not implemented—by the superclass.
Note that JavaScript does not have any formal definition of abstract
methods or abstract classes; I’m simply using that name here for
unimplemented methods and incompletely implemented classes.</p>

<p><a data-type="xref" href="#sets.js">Example 9-8</a> is well commented and stands on its own. I encourage you
to read it as a capstone example for this chapter on classes. The
final class in <a data-type="xref" href="#sets.js">Example 9-8</a> does a lot of bit manipulation with the
<code>&amp;</code>, <code>|</code>, and <code>~</code> operators, which you can review in <a data-type="xref" href="ch04.xhtml#bitwiseoperators">§4.8.3</a>.</p>
<div id="sets.js" data-type="example">
<h5><span class="label">Example 9-8. </span>Sets.js: a hierarchy of abstract and concrete set classes</h5>

<pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
<code class="cm"> * The AbstractSet class defines a single abstract method, has().</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
    <code class="c1">// Throw an error here so that subclasses are forced</code>
    <code class="c1">// to define their own working version of this method.</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
<code class="p">}</code>

<code class="cm">/**</code>
<code class="cm"> * NotSet is a concrete subclass of AbstractSet.</code>
<code class="cm"> * The members of this set are all values that are not members of some</code>
<code class="cm"> * other set. Because it is defined in terms of another set it is not</code>
<code class="cm"> * writable, and because it has infinite members, it is not enumerable.</code>
<code class="cm"> * All we can do with it is test for membership and convert it to a</code>
<code class="cm"> * string using mathematical notation.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">NotSet</code> <code class="kr">extends</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">set</code> <code class="o">=</code> <code class="nx">set</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// Our implementation of the abstract method we inherited</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code> <code class="p">}</code>
    <code class="c1">// And we also override this Object method</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{ x| x ∉ </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">set</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb"> }`</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="cm">/**</code>
<code class="cm"> * Range set is a concrete subclass of AbstractSet. Its members are</code>
<code class="cm"> * all values that are between the from and to bounds, inclusive.</code>
<code class="cm"> * Since its members can be floating point numbers, it is not</code>
<code class="cm"> * enumerable and does not have a meaningful size.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">RangeSet</code> <code class="kr">extends</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{ x| </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb"> ≤ x ≤ </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="si">}</code><code class="sb"> }`</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="cm">/*</code>
<code class="cm"> * AbstractEnumerableSet is an abstract subclass of AbstractSet.  It defines</code>
<code class="cm"> * an abstract getter that returns the size of the set and also defines an</code>
<code class="cm"> * abstract iterator. And it then implements concrete isEmpty(), toString(),</code>
<code class="cm"> * and equals() methods on top of those. Subclasses that implement the</code>
<code class="cm"> * iterator, the size getter, and the has() method get these concrete</code>
<code class="cm"> * methods for free.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">AbstractEnumerableSet</code> <code class="kr">extends</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
    <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
    <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>

    <code class="nx">isEmpty</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">===</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{</code><code class="si">${</code><code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="k">this</code><code class="p">).</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">)</code><code class="si">}</code><code class="sb">}`</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">equals</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// If the other set is not also Enumerable, it isn't equal to this one</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">set</code> <code class="k">instanceof</code> <code class="nx">AbstractEnumerableSet</code><code class="p">))</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>

        <code class="c1">// If they don't have the same size, they're not equal</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">!==</code> <code class="nx">set</code><code class="p">.</code><code class="nx">size</code><code class="p">)</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>

        <code class="c1">// Loop through the elements of this set</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If an element isn't in the other set, they aren't equal</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="c1">// The elements matched, so the sets are equal</code>
        <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="cm">/*</code>
<code class="cm"> * SingletonSet is a concrete subclass of AbstractEnumerableSet.</code>
<code class="cm"> * A singleton set is a read-only set with a single member.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">SingletonSet</code> <code class="kr">extends</code> <code class="nx">AbstractEnumerableSet</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">member</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">member</code> <code class="o">=</code> <code class="nx">member</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="c1">// We implement these three methods, and inherit isEmpty, equals()</code>
    <code class="c1">// and toString() implementations based on these methods.</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">===</code> <code class="k">this</code><code class="p">.</code><code class="nx">member</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">1</code><code class="p">;</code> <code class="p">}</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">yield</code> <code class="k">this</code><code class="p">.</code><code class="nx">member</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code>

<code class="cm">/*</code>
<code class="cm"> * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet.</code>
<code class="cm"> * It defines the abstract methods insert() and remove() that insert and</code>
<code class="cm"> * remove individual elements from the set, and then implements concrete</code>
<code class="cm"> * add(), subtract(), and intersect() methods on top of those. Note that</code>
<code class="cm"> * our API diverges here from the standard JavaScript Set class.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">AbstractWritableSet</code> <code class="kr">extends</code>  <code class="nx">AbstractEnumerableSet</code> <code class="p">{</code>
    <code class="nx">insert</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
    <code class="nx">remove</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>

    <code class="nx">add</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">insert</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="nx">subtract</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="nx">intersect</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="cm">/**</code>
<code class="cm"> * A BitSet is a concrete subclass of AbstractWritableSet with a</code>
<code class="cm"> * very efficient fixed-size set implementation for sets whose</code>
<code class="cm"> * elements are non-negative integers less than some maximum size.</code>
<code class="cm"> */</code>
<code class="kr">class</code> <code class="nx">BitSet</code> <code class="kr">extends</code> <code class="nx">AbstractWritableSet</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">max</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">max</code> <code class="o">=</code> <code class="nx">max</code><code class="p">;</code>  <code class="c1">// The maximum integer we can store.</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>      <code class="c1">// How many integers are in the set</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">numBytes</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">max</code> <code class="o">/</code> <code class="mi">8</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>   <code class="c1">// How many bytes we need</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">data</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">numBytes</code><code class="p">);</code> <code class="c1">// The bytes</code>
    <code class="p">}</code>

    <code class="c1">// Internal method to check if a value is a legal member of this set</code>
    <code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">max</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// Tests whether the specified bit of the specified byte of our</code>
    <code class="c1">// data array is set or not. Returns true or false.</code>
    <code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">data</code><code class="p">[</code><code class="kr">byte</code><code class="p">]</code> <code class="o">&amp;</code> <code class="nx">BitSet</code><code class="p">.</code><code class="nx">bits</code><code class="p">[</code><code class="nx">bit</code><code class="p">])</code> <code class="o">!==</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// Is the value x in this BitSet?</code>
    <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="kr">byte</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">/</code> <code class="mi">8</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">bit</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">8</code><code class="p">;</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="c1">// Insert the value x into the BitSet</code>
    <code class="nx">insert</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>               <code class="c1">// If the value is valid</code>
            <code class="kd">let</code> <code class="kr">byte</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">/</code> <code class="mi">8</code><code class="p">);</code>   <code class="c1">// convert to byte and bit</code>
            <code class="kd">let</code> <code class="nx">bit</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">8</code><code class="p">;</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">))</code> <code class="p">{</code>    <code class="c1">// If that bit is not set yet</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">data</code><code class="p">[</code><code class="kr">byte</code><code class="p">]</code> <code class="o">|=</code> <code class="nx">BitSet</code><code class="p">.</code><code class="nx">bits</code><code class="p">[</code><code class="nx">bit</code><code class="p">];</code> <code class="c1">// then set it</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">n</code><code class="o">++</code><code class="p">;</code>                            <code class="c1">// and increment set size</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"Invalid set element: "</code> <code class="o">+</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="nx">remove</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>              <code class="c1">// If the value is valid</code>
            <code class="kd">let</code> <code class="kr">byte</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">/</code> <code class="mi">8</code><code class="p">);</code>  <code class="c1">// compute the byte and bit</code>
            <code class="kd">let</code> <code class="nx">bit</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">8</code><code class="p">;</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">))</code> <code class="p">{</code>    <code class="c1">// If that bit is already set</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">data</code><code class="p">[</code><code class="kr">byte</code><code class="p">]</code> <code class="o">&amp;=</code> <code class="nx">BitSet</code><code class="p">.</code><code class="nx">masks</code><code class="p">[</code><code class="nx">bit</code><code class="p">];</code>  <code class="c1">// then unset it</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">n</code><code class="o">--</code><code class="p">;</code>                              <code class="c1">// and decrement size</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"Invalid set element: "</code> <code class="o">+</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="c1">// A getter to return the size of the set</code>
    <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">n</code><code class="p">;</code> <code class="p">}</code>

    <code class="c1">// Iterate the set by just checking each bit in turn.</code>
    <code class="c1">// (We could be a lot more clever and optimize this substantially)</code>
    <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">max</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">i</code><code class="p">))</code> <code class="p">{</code>
                <code class="k">yield</code> <code class="nx">i</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Some pre-computed values used by the has(), insert() and remove() methods</code>
<code class="nx">BitSet</code><code class="p">.</code><code class="nx">bits</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">128</code><code class="p">]);</code>
<code class="nx">BitSet</code><code class="p">.</code><code class="nx">masks</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">([</code><code class="o">~</code><code class="mi">1</code><code class="p">,</code> <code class="o">~</code><code class="mi">2</code><code class="p">,</code> <code class="o">~</code><code class="mi">4</code><code class="p">,</code> <code class="o">~</code><code class="mi">8</code><code class="p">,</code> <code class="o">~</code><code class="mi">16</code><code class="p">,</code> <code class="o">~</code><code class="mi">32</code><code class="p">,</code> <code class="o">~</code><code class="mi">64</code><code class="p">,</code> <code class="o">~</code><code class="mi">128</code><code class="p">]);</code></pre></div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="9.6 Summary"><div class="sect1" id="idm46198532598344">
<h1>9.6 Summary</h1>

<p>This<a data-type="indexterm" data-primary="" data-startref="abstc09" id="idm46198532597208"/><a data-type="indexterm" data-primary="" data-startref="Shier09" id="idm46198532596200"/><a data-type="indexterm" data-primary="" data-startref="Csubhier09" id="idm46198532595256"/> chapter has explained the key features of JavaScript classes:</p>

<ul>
<li>
<p>Objects that are members of the same class inherit properties from
the same prototype object. The prototype object is the key feature
of JavaScript classes, and it is possible to define classes with
nothing more than the <code>Object.create()</code> method.</p>
</li>
<li>
<p>Prior to ES6, classes were more typically defined by first defining
a constructor function. Functions created with the <code>function</code>
keyword have a <code>prototype</code> property, and the value of this property
is an object that is used as the prototype of all objects created
when the function is invoked with <code>new</code> as a constructor. By
initializing this prototype object, you can define the shared methods
of your class. Although the prototype object is the key
feature of the class, the constructor function is the public
identity of the class.</p>
</li>
<li>
<p>ES6 introduces a <code>class</code> keyword that makes it easier to define
classes, but under the hood, constructor and prototype mechanism
remains the same.</p>
</li>
<li>
<p>Subclasses are defined using the <code>extends</code> keyword in a class
declaration.</p>
</li>
<li>
<p>Subclasses can invoke the constructor of their superclass or
overridden methods of their superclass with the <code>super</code> keyword.</p>
</li>
</ul>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46198535317032"><sup><a href="ch09.xhtml#idm46198535317032-marker">1</a></sup> Except functions returned by the ES5<a data-type="indexterm" data-primary="ES5" data-secondary="Function.bind() method" id="idm46198535316472"/> <code>Function.bind()</code> method. Bound functions have no prototype property of their own, but they use the prototype of the underlying function if they are invoked as constructors.</p><p data-type="footnote" id="idm46198532816792"><sup><a href="ch09.xhtml#idm46198532816792-marker">2</a></sup> See <em>Design Patterns</em> (Addison-Wesley Professional) by Erich Gamma et al. or <em>Effective Java</em> (Addison-Wesley Professional) by Joshua Bloch, for example.</p></div></div></section></div>



  </body>
</html>